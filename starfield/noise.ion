
var perlin_gradients: float2* = 0;
const PerlinGradientCountRoot = 16;
const PerlinGradientCount = PerlinGradientCountRoot*PerlinGradientCountRoot;
#static_assert((PerlinGradientCount & (PerlinGradientCount - 1)) == 0)
func perlin_gradient(p: int2): float2 {
    result := float2 {};

    if (perlin_gradients == 0) {
        for (i := 0; i < PerlinGradientCount; i++) {
            v := random_unit_vector2();
            buf_push((:void**)&perlin_gradients, &v, sizeof(v));
        }
    }

    result = perlin_gradients[(int(p.y)*PerlinGradientCountRoot + int(p.x)) & (PerlinGradientCount -1)];
    return result;
}

func perlin(p: float2, grid_size: float): float {
    p.x = mod(p.x * grid_size, grid_size);
    p.y = mod(p.y * grid_size, grid_size);

    a := float2_to_int2(p);
    b := float2_to_int2(mod2s(add2(p, {1, 0}), grid_size));
    c := float2_to_int2(mod2s(add2(p, {0, 1}), grid_size));
    d := float2_to_int2(mod2s(add2(p, {1, 1}), grid_size));

    A := perlin_gradient(a);
    B := perlin_gradient(b);
    C := perlin_gradient(c);
    D := perlin_gradient(d);

    pp: float2 = { p.x - int(p.x), p.y - int(p.y) };

    u00 := dot2(A, sub2(pp, {0,0}));
    u10 := dot2(B, sub2(pp, {1,0}));
    u01 := dot2(C, sub2(pp, {0,1}));
    u11 := dot2(D, sub2(pp, {1,1}));

    x := pp.x*pp.x*(3. - 2.*pp.x);
    y := pp.y*pp.y*(3. - 2.*pp.y);

    ab := lerp(u00, u10, x);
    cd := lerp(u01, u11, x);
    abcd := lerp(ab, cd, y);

    return abcd;
}

func perlin_octaves(p: float2, grid_size: float): float {
   return (1 / (.5+.25+.125+.0625)) *
      perlin(p, grid_size) * 0.5
    + perlin(mul2s(p, 1.5), grid_size) * 0.25
    + perlin(mul2s(p, 3.), grid_size) * 0.125
    + perlin(mul2s(p, 4.2), grid_size) * 0.0625;
}

const WorleyMaxPointsPerSquare = 6;

struct WorleySquare {
    count: int;
    points: float2[WorleyMaxPointsPerSquare];
}

var worley_squares: WorleySquare* = 0;
const WorleySquareCountRoot = 16;
const WorleySquareCount = WorleySquareCountRoot*WorleySquareCountRoot;
#static_assert(WorleySquareCount & (WorleySquareCount - 1) == 0)
func worley_square(p: float2): WorleySquare* {
    result: WorleySquare* = 0;

    if (worley_squares == 0) {
        alpha := exp(-2.01);

        for (i := 0; i < WorleySquareCount; i++) {
            w := WorleySquare {};
            w.count = clampi(1, WorleyMaxPointsPerSquare, random_poisson(alpha));
            for (j := 0; j < w.count; j++) {
                w.points[j] = { random01(), random01() };
            }
            buf_push((:void**)&worley_squares, &w, sizeof(w));
        }
    }

    result = worley_squares + ((int(p.y)*WorleySquareCountRoot + int(p.x)) & (WorleySquareCount -1));
    return result;
}

func worley(p01: float2, grid_size: float): float2 {
    p := mul2s(p01, grid_size);
    pi := floor2(p);
    pf := sub2(p, pi);

    f1 := 2*Sqrt2;
    f2 := f1;

    hit := false;

    // yes, this is faster than a loop

    {
        w := worley_square(pi);

        for (m := 0; m < w.count; m++) {
            d := distance_squared2(pf, w.points[m]);
            if (d < f1) {
                f2 = f1;
                f1 = d;
            } else if (d < f2) {
                f2 = d;
            }
        }

        // Early out. This is 5%~ of cases
        min_dist := square(min(min(pf.x, 1 - pf.x), min(pf.y, 1 - pf.y)));
        if (f2 < min_dist) {
            return { sqrt(f1), sqrt(f2) };
        }
    }

    {
        i := -1.;
        j := 0.;
        face_dist := square(pf.x);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 1.;
        j := 0.;
        face_dist := square(1. - pf.x);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 0.;
        j := -1.;
        face_dist := square(pf.y);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 0.;
        j := 1.;
        face_dist := square(1. - pf.y);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := -1.;
        j := -1.;
        face_dist := magnitude_squared2({ pf.x, pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }


    {
        i := 1.;
        j := -1.;
        face_dist := magnitude_squared2({ 1. - pf.x, pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := -1.;
        j := 1.;
        face_dist := magnitude_squared2({ pf.x, 1. - pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 1.;
        j := 1.;
        face_dist := magnitude_squared2({ 1. - pf.x, 1. - pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    #assert(f1 <= f2);
    #assert(f2 >= 0);
    return { sqrt(f1), sqrt(f2) };
}

func worley_octaves(p: float2, grid_size: float): float2 {
    s := (1 / (.5+.25+.125+.0625));
    a := mul2s(worley(p, grid_size), 0.5);
    b := mul2s(worley(mul2s(p, 1.5), grid_size), 0.25);
    c := mul2s(worley(mul2s(p, 3.), grid_size), 0.125);
    d := mul2s(worley(mul2s(p, 4.2), grid_size), 0.0625);

    return mul2s(add2(a, add2(b, add2(c, d))), s);
}

func random_warp_one(p: float2, scale: float): float2 {
    a := rwo_gradient(float2_to_int2(add2(p, { 0, 0 })));
    b := rwo_gradient(float2_to_int2(add2(p, { 1, 0 })));
    c := rwo_gradient(float2_to_int2(add2(p, { 0, 1 })));
    d := rwo_gradient(float2_to_int2(add2(p, { 1, 1 })));
    r := float2 { p.x - int(p.x), p.y - int(p.y) };

    x := r.x*r.x*(3. - 2.*r.x);
    y := r.y*r.y*(3. - 2.*r.y);

    ab := lerp2(a, b, x);
    cd := lerp2(c, d, x);
    abcd := lerp2(ab, cd, y);

    return mul2s(abcd, scale);
}

func random_warp_scalar(p: float2, freq: float, scale: float): float2 {
    a := 1.;
    b := a*.5;
    c := b*.5;
    d := c*.5;

    q := mul2s(p, freq);
    return add2(p, mul2s(add2(random_warp_one(q, a),
                         add2(random_warp_one(mul2s(q, 2), b),
                         add2(random_warp_one(mul2s(q, 4), c),
                              random_warp_one(mul2s(q, 8), d)))),
                    scale / (a+b+c+d)));
}

struct float4x2 {
    x: float4;
    y: float4;
}

func rwo_gradient_sse(px: float4, py: float4): float4x2 {
    pxi := float4_to_int4(px);
    pyi := float4_to_int4(py);
    H0 := set4si(0x811c9dc5);
    H1 := set4si(16777619);
    h := mul4i(xor4i(mul4i(xor4i(pxi, H0), H1), pyi), H1);
    a := xor4i(h, shl4si(h, 13));
    a  = xor4i(a, shr4si(a, 17));
    a  = xor4i(a, shl4si(a, 5));
    b := cast_int4_to_float4(or4i(and4i(a, set4si(f_sig_mask)), set4si(f_exp_1_2_mask)));
    c := sub4(b, set4s(1));
    x := sqrt4(c);
    y := sqrt4(sub4(set4s(1), c));

    x_sign := and4i(a, set4si(1 << 31));
    y_sign := and4i(shl4si(a, 1), set4si(1 << 31));

    return { cast_int4_to_float4(add4i(cast_float4_to_int4(x), x_sign)), cast_int4_to_float4(add4i(cast_float4_to_int4(y), y_sign)) };
}

func random_warp_sse(p: float2, freq: float, scale: float): float2 {
    one := set4s(1.);
    two := set4s(2.);
    three := set4s(3.);

    scale4 := set4(0.125, 0.25, 0.5, 1);
    octave := set4(8, 4, 2, 1);

    qx := mul4(set4s(p.x * freq), octave);
    qy := mul4(set4s(p.y * freq), octave);
    qxi := floor4(qx);
    qyi := floor4(qy);
    qxi1 := add4(qxi, one);
    qyi1 := add4(qyi, one);

    a := rwo_gradient_sse(qxi, qyi);
    b := rwo_gradient_sse(qxi1, qyi);
    c := rwo_gradient_sse(qxi, qyi1);
    d := rwo_gradient_sse(qxi1, qyi1);

    rx := sub4(qx, qxi);
    ry := sub4(qy, qyi);

    x := mul4(mul4(rx, rx), sub4(three, mul4(rx, two)));
    y := mul4(mul4(ry, ry), sub4(three, mul4(ry, two)));

    abx := lerp4(a.x, b.x, x);
    aby := lerp4(a.y, b.y, x);
    cdx := lerp4(c.x, d.x, x);
    cdy := lerp4(c.y, d.y, x);
    abcdx := mul4(lerp4(abx, cdx, y), scale4);
    abcdy := mul4(lerp4(aby, cdy, y), scale4);

    xy01 := unpacklo4(abcdx, abcdy);
    xy23 := unpackhi4(abcdx, abcdy);

    xyxy := add4(xy01, xy23);
    x_y_ := unpackhi4(xyxy, xyxy);

    offset := add4(xyxy, x_y_);

    p4 := set4(0, 0, p.y, p.x);
    result4 := add4(p4, mul4s(offset, scale / (1 + 0.5 + 0.25 + 0.125)));

    // Dumb, but the compiler does the right thing.
    result: float2[2] = {};
    storeu4((:float*)result, result4);
    return result[0];
}

func random_warp(p: float2, freq: float, scale: float): float2 {
    return random_warp_sse(p, freq, scale);
}