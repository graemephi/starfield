import libc { ... }
import sdl { ... }
import noir { ... }

#foreign(header = "<sdl_bits.h>")

@foreign
func isnan(f: float): bool;

#foreign(header = "<xmmintrin.h>")

@foreign
func _MM_SET_FLUSH_ZERO_MODE(mask: uint32);

@foreign
var _MM_FLUSH_ZERO_ON: uint32;

var ImageSize: int2 const = { 512, 512 };

func xrealloc(mem: void*, size: usize): void* {
    result := realloc(mem, size);
    if (!result) {
        printf("Failed to realloc");
        #assert(0);
        exit(1);
    }
    return result;
}

func xmalloc(size: usize): void* {
    result := malloc(size);
    if (!result) {
        printf("Failed to malloc");
        #assert(0);
        exit(1);
    }
    memset(result, 0, size);
    return result;
}

func xcalloc(count: usize, size: usize): void* {
    result := calloc(count, size);
    if (!result) {
        printf("Failed to calloc");
        #assert(0);
        exit(1);
    }
    return result;
}

struct Color {
    r, g, b, a: float;
}

struct RGB8 {
    b, g, r: uint8;
    padding: uint8;
} #static_assert(sizeof(RGB8) == 4)


struct Tex {
    pixels: Color*;
    size: int2;
    lod_levels: int;
}

func make_tex(size: int2): Tex {
    #assert(is_power_2(size.x));
    #assert(size.x == size.y);
    // Allocate space for lods as well.
    pixels := xcalloc(size.x*size.y*4, sizeof(Color));
    return Tex {
        size = size,
        lod_levels = 1,
        pixels = pixels
    };
}

func free_tex(tex: Tex*) {
    #assert(tex.pixels);
    free(tex.pixels);
    tex.pixels = 0;
    tex.size = { 0, 0 };
}

func compute_lod_level(dest_size: int2, target_size: float2, src_size: int2): float2 {
    step_x := fabs(src_size.x / (dest_size.x * target_size.x));
    step_y := fabs(src_size.y / (dest_size.y * target_size.y));
    return { max(0, log2(step_x)), max(0, log2(step_y)) };
}

// Axis-aligned anisotropic filtering
func generate_lods(tex: Tex*) {
    #assert(tex.size.x == tex.size.y);
    tex.lod_levels = maxi(1, log2i(tex.size.x));

    blurry := image_copy(&{tex.pixels, tex.size});

    size := tex.size;
    for (i := 0; i < tex.lod_levels; i++) {
        #assert(size.x >= 1);
        #assert(size.y >= 1);

        if (i > 0) {
            // Square pyramid
            prev_lod := tex_get_lod(tex, { i - 1, i - 1 });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_to(&blurry_subrect, &prev_lod, .707);
            lod := tex_get_lod(tex, { i, i });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_nearest(&blurry_subrect, it.pos);
            }
        }

        for (j := i + 1; j < tex.lod_levels; j++) {
            prev_lod := tex_get_lod(tex, { j - 1, i  });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_horizontal(&blurry_subrect, &prev_lod, 0.5);
            lod := tex_get_lod(tex, { j, i });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_nearest(&blurry_subrect, it.pos);
            }
        }

        for (k := i + 1; k < tex.lod_levels; k++) {
            prev_lod := tex_get_lod(tex, { i, k - 1 });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_vertical(&blurry_subrect, &prev_lod, 0.5);
            lod := tex_get_lod(tex, { i, k });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_nearest(&blurry_subrect, it.pos);
            }
        }
    }

    free_image(&blurry);
}

func tex_poke(tex: Tex*, pos: int2, val: Color) {
    #assert(tex.lod_levels == 1);

    // Todo: assert?
    pos.x = clampi(0, tex.size.x - 1, pos.x);
    pos.y = clampi(0, tex.size.y - 1, pos.y);
    idx := pos.x + tex.size.x*pos.y;

    tex.pixels[idx] = val;
}


func tex_get_lod(tex: Tex*, lod: int2): Image {
    // Pixels are laid out as: Series of decreasing mips
    // Each mip is a square mip, followed by decreasing mips in the x axis, then
    // decreasing mips in the y axis

    #assert(lod.x >= 0);
    #assert(lod.y >= 0);

    if (lod.x >= tex.lod_levels || lod.y >= tex.lod_levels) {
        return {};
    }

    square_level := mini(lod.x, lod.y);
    square_size := int2 { tex.size.x >> square_level, tex.size.y >> square_level };
    square_area := square_size.x*square_size.y;
    square_lod := Image { tex.pixels + tex.size.x*tex.size.y*4 - square_area*4, square_size };

    lod_size := int2 { tex.size.x >> lod.x, tex.size.y >> lod.y };
    #assert(lod_size.x == square_lod.size.x || lod_size.y == square_lod.size.y);

    // Non-square lod sizes decrease geometrically, 1, 1/2, 1/4, 1/8, so their
    // location is the running sum, (2^n - 1)/2^n * area(lod_square).
    denom_bit := abs(lod.x - lod.y) - 1;
    numer := (1 << denom_bit) - 1;

    pixels := square_lod.pixels;
    if (lod.x > lod.y) {
        pixels += square_area + ((numer*square_area) >> denom_bit);
        #assert(pixels < square_lod.pixels + square_area*2);
    } else if (lod.y > lod.x) {
        pixels += square_area*2 + ((numer*square_area) >> denom_bit);
        #assert(pixels < square_lod.pixels + square_area*4);
    }

    #assert(pixels < tex.pixels + tex.size.x*tex.size.y*4);
    return { pixels, lod_size };
}

func tex_lookup(tex: Tex*, pos: float2): Color {
    return image_sample_linear(&{tex.pixels, tex.size}, pos);
}

func tex_lookup_lod(tex: Tex*, pos: float2, lod: float2): Color {
    result := Color {};
    if (lod.x == lod.y) {
        lodi := float2_to_int2(lod);
        lodf := float2 { lod.x - lodi.x, lod.x - lodi.x };
        a_lod := tex_get_lod(tex, lodi);
        b_lod := tex_get_lod(tex, add2is(lodi, 1));
        a := image_sample_linear(&a_lod, pos);
        if (lodf.x > 0.0001) {
            b := image_sample_linear(&b_lod, pos);
            return  color_lerp(a, b, lodf.x);
        }

        return a;
    }

    lodi := float2_to_int2(lod);
    lodf := float2 { lod.x - lodi.x, lod.y - lodi.y };
    a_lod := tex_get_lod(tex, lodi);
    b_lod := tex_get_lod(tex, add2i(lodi, { 1, 0 }));
    c_lod := tex_get_lod(tex, add2i(lodi, { 0, 1 }));
    d_lod := tex_get_lod(tex, add2i(lodi, { 1, 1 }));
    a := image_sample_linear(&a_lod, pos);
    b := image_sample_linear(&b_lod, pos);
    c := image_sample_linear(&c_lod, pos);
    d := image_sample_linear(&d_lod, pos);
    ab := color_lerp(a, b, lodf.x);
    cd := color_lerp(c, d, lodf.x);
    abcd := color_lerp(ab, cd, lodf.y);
    return abcd;
}

func draw_tex(dest: Image*, target: Rect, tex: Tex*) {
    if (is_zero(&target, sizeof(target))) {
        target = all_rect();
    }
    lod := compute_lod_level(dest.size, target.size, tex.size);
    for (it := pixel_iter_begin(dest, target); pixel_iter_next(&it)) {
        rgba := tex_lookup_lod(tex, it.pos, lod);
        *it.pixel = color_blend(*it.pixel, rgba);
    }
}

func draw_tex_multiply(dest: Image*, target: Rect, tex: Tex*, multiply_color: Color) {
    lod := compute_lod_level(dest.size, target.size, tex.size);
    for (it := pixel_iter_begin(dest, target); pixel_iter_next(&it)) {
        rgba := tex_lookup_lod(tex, it.pos, lod);
        rgba = color_mul(rgba, multiply_color);
        *it.pixel = color_blend(*it.pixel, rgba);
    }
}

func all_rect(): Rect {
    return {
        pos = { 0.5, 0.5 },
        size = { 1, 1 },
        rot = { 1, 0 }
    };
}

func rotate(v: float2, cos_sin_theta: float2): float2 {
    return float2 {
        v.x * cos_sin_theta.x - v.y * cos_sin_theta.y,
        v.x * cos_sin_theta.y + v.y * cos_sin_theta.x
    };
}

func rotate_theta(v: float2, theta: float): float2 {
    return rotate(v, { cos(theta), sin(theta) });
}

func inside_normal_rect(pos: float2): bool {
    return pos.x >= 0 && pos.x < 1
        && pos.y >= 0 && pos.y < 1;
}

func inside_rect(rect: Rect, pos: float2): bool {
    return inside_normal_rect(rect_relative(rect, pos));
}

func rect_relative(rect: Rect, abs_pos: float2): float2 {
    shift_pos := sub2(abs_pos, rect.pos);
    rot_pos := rotate(shift_pos, rect.rot);
    scaled_pos := div2(rot_pos, rect.size);
    result := add2(scaled_pos, { 0.5, 0.5 });
    return result;
}

func rect_absolute(rect: Rect, rel_pos: float2): float2 {
    centered_pos := sub2(rel_pos, { 0.5, 0.5 });
    scaled_pos := mul2(centered_pos, rect.size);
    rot_pos := rotate(scaled_pos, { rect.rot.x, -rect.rot.y });
    shift_pos := add2(rot_pos, rect.pos);
    return shift_pos;
}

func gray(c: float): Color {
    return { c, c, c, 1 };
}

func color_lerp(a: Color, b: Color, t: float): Color {
    return Color {
        lerp(a.r, b.r, t),
        lerp(a.g, b.g, t),
        lerp(a.b, b.b, t),
        lerp(a.a, b.a, t),
    };
}

func color_add(a: Color, b: Color): Color {
    return Color {
        a.r + b.r,
        a.g + b.g,
        a.b + b.b,
        a.a + b.a
    };
}

func color_sub(a: Color, b: Color): Color {
    return Color {
        a.r - b.r,
        a.g - b.g,
        a.b - b.b,
        a.a - b.a
    };
}

func color_mul(a: Color, b: Color): Color {
    return Color {
        a.r * b.r,
        a.g * b.g,
        a.b * b.b,
        a.a * b.a
    };
}

func color_mul1(a: Color, b: float): Color {
    return Color {
        a.r * b,
        a.g * b,
        a.b * b,
        a.a * b
    };
}

func color_mul_rgb1(a: Color, b: float): Color {
    return Color {
        a.r * b,
        a.g * b,
        a.b * b,
        a.a
    };
}
func color_blend(dest: Color, src: Color): Color {
    return Color {
        src.r + (dest.r * (1. - src.a)),
        src.g + (dest.g * (1. - src.a)),
        src.b + (dest.b * (1. - src.a)),
        src.a + (dest.a * (1. - src.a))
    };
}

func color_premultiply(c: Color, alpha: float): Color {
    return Color {
        c.r * alpha,
        c.g * alpha,
        c.b * alpha,
        c.a * alpha
    };
}


func is_zero(buf: void const*, len: usize): bool {
    p := (:char const*)buf;
    if (*p) {
        return false;
    }

    return memcmp(p + 1, buf, len - 1) == 0;
}

func srgb(val: float): float {
    #assert(!isnan(val));
    val = clamp01(val);

    if (val <= 0.0031308) {
        return val * 12.92;
    }

    return 1.055 * pow(val, 1./2.4) - 0.055;
}

func color_to_rgb8(color: Color): RGB8 {
    result := RGB8 {
        r = uint8(srgb(color.r) * 255.),
        g = uint8(srgb(color.g) * 255.),
        b = uint8(srgb(color.b) * 255.),
    };
    return result;
}

// Set in main, used for anything that should be aligned with diffraction.
var diffraction_rotation: float2 = {};

func draw_starfield(dest: Image*, starfield: Starfield*) {
    for (i := starfield_len(starfield) - 1; i >= 0; i--) {
        star := starfield.stars + i;
        draw_tex_multiply(dest, star.rect, &star.type.tex, star.color);
    }
}

func time_now(): double {
    ticks := SDL_GetPerformanceCounter() - app.time.sdl_start_ticks;
    return double(ticks) / double(app.time.ticks_per_sec);
}

const perlin_gradient_count = 128;
var perlin_gradients: float2[perlin_gradient_count];
func init_perlin() {
    for (i := 0; i < perlin_gradient_count; i++) {
        perlin_gradients[i] =  random_unit_vector2();
    }
}

func hash(p: int2): int64 {
    h := 1099511628211;
    b := (:uint8*)&p;
    for (i := 0; i < sizeof(p); i++) {
        h ^= b[i];
        h *= 0xcbf29ce484222325;
    }
    return h;
}

func perlin(p: float2, gradients_per_side: int): float {
    grid := float(gradients_per_side);

    p.x = mod(p.x * grid, grid);
    p.y = mod(p.y * grid, grid);

    a := float2_to_int2(p);
    b := float2_to_int2(mod2s(add2(p, {1, 0}), grid));
    c := float2_to_int2(mod2s(add2(p, {0, 1}), grid));
    d := float2_to_int2(mod2s(add2(p, {1, 1}), grid));

    A := perlin_gradients[hash(a) & (perlin_gradient_count - 1)];
    B := perlin_gradients[hash(b) & (perlin_gradient_count - 1)];
    C := perlin_gradients[hash(c) & (perlin_gradient_count - 1)];
    D := perlin_gradients[hash(d) & (perlin_gradient_count - 1)];

    pp: float2 = { p.x - int(p.x), p.y - int(p.y) };

    u00 := dot2(A, sub2(pp, {0,0}));
    u10 := dot2(B, sub2(pp, {1,0}));
    u01 := dot2(C, sub2(pp, {0,1}));
    u11 := dot2(D, sub2(pp, {1,1}));

    x := -2*pp.x*pp.x*pp.x + 3*pp.x*pp.x;
    y := -2*pp.y*pp.y*pp.y + 3*pp.y*pp.y;

    ab := lerp(u00, u10, x);
    cd := lerp(u01, u11, x);
    abcd := lerp(ab, cd, y);

    return abcd;
}

func perlin_octaves(p: float2, grid: int): float {
   return (1 / (.5+.25+.125+.0625)) *
      perlin(p, grid) * 0.5
    + perlin(mul2s(p, 1.5), grid) * 0.25
    + perlin(mul2s(p, 3.), grid) * 0.125
    + perlin(mul2s(p, 4.2), grid) * 0.0625;
}

func main(argc: int, argv: char**): int {
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);

    app.window.size = ImageSize;
    if (!app_init()) {
        print_and_clear_error();
        return 1;
    }

    printf("Platform: %s\n", app.platform);
    printf("Display: %d x %d, %d Hz, %.2f DPI\n", app.display.size.x, app.display.size.y, app.display.rate, app.display.dpi);

    surface := SDL_GetWindowSurface(app.window.sdl);
    renderer := SDL_CreateSoftwareRenderer(surface);
    #assert(surface.format.format == SDL_PIXELFORMAT_RGB888);
    #assert(surface.format.BitsPerPixel == 32);

    starfield_text :="""
✺   　　 　　 ·   ⊹
 *  ⋆ 　　　  ✧  *
  　　　　　　　.  　
 +  *　  　* 　　. 　 ⋆
  ✫ 　　  +
""";

    // Todo: init after seeding random
    init_perlin();
    noise := make_image({ surface.w, surface.h });
    for (it := pixel_iter_begin(&noise, {}); pixel_iter_next(&it)) {
        c := Color {
            square(random_normal()) * (1 / 2048.),
            square(random_normal()) * (1 / 2048.),
            square(random_normal()) * (1 / 2048.),
            1
        };
        *it.pixel = c;
    }
    blur(&noise, 0.1);

    diffraction_rotation = random_unit_vector2();random_unit_vector2();random_unit_vector2();random_unit_vector2();

    starfield := create_starfield(starfield_text);

    min_t := 1000.;
    max_t := 0.;
    sum_t := 0.;
    n_t := 0;
    t_reset := time_now();

    image := make_image({ surface.w, surface.h });
    blurred := make_image({ surface.w, surface.h });
    blurred2 := make_image({ surface.w, surface.h });
    while (app_update()) {
        if (app.error) {
            print_and_clear_error();
        }

        if (!n_t || app.mouse.left_button.pressed) {
            image_copy_to(&image, &noise);

            t0 := time_now();
            t0f := float(t0);

            draw_starfield(&image, &starfield);
            diffract(&image, {
                alpha = 0.1,
                radius = 4,
                transform = diffraction_rotation,
                type = randomn(1, DiffractionTypeCount)
            });

            blur_to(&blurred, &image, randomr(0, 1)); // ~1.33
            blur_to(&blurred2, &image, randomr(0.5,1)); // ~2
            for (it := pixel_iter_begin(&image, {}); pixel_iter_next(&it)) {
                bp := image_fetch(&blurred, it.pixel_pos);
                mbp := color_mul(*it.pixel, bp);
                xbp := color_lerp(bp, mbp, 0.1);

                bp2 := image_fetch(&blurred2, it.pixel_pos);
                mbp2 := color_mul(*it.pixel, bp2);
                xbp2 := color_lerp(bp2, mbp2, .9);
                *it.pixel = color_add(*it.pixel, color_add(xbp, xbp2));
            }

            image_to_rgb8((:RGB8*)surface.pixels,  { surface.w, surface.h }, &image);

            t1 := time_now();

            t := float((t1 - t0)*1000);
            min_t = min(t, min_t);
            max_t = max(t, max_t);
            sum_t += t;
            n_t++;

            if (app.mouse.left_button.pressed) {
                init_star_type_really(star_types + 12, true);

                printf("min %.2fms max %.2fms avg %.2fms\n", min_t, max_t, sum_t/n_t);

                free(stars_header(starfield.stars));
                starfield = create_starfield(starfield_text);
                t_reset = t0;
            }
        }

        SDL_UpdateWindowSurface(app.window.sdl);

        fflush(stdout);
        SDL_Delay(10);
    }

    return 0;
}