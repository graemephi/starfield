import libc { ... }
import sdl { ... }
import noir { ... }

// https://en.wikipedia.org/wiki/Einstein_Cross

var ImageSize: int2 const = { 500, 500 };

const Pi = PI;
const Tau = Pi*2;

func xrealloc(mem: void*, size: usize): void* {
    result := realloc(mem, size);
    if (!result) {
        printf("Failed to realloc");
        #assert(0);
        exit(1);
    }
    return result;
}

func xmalloc(size: usize): void* {
    result := malloc(size);
    if (!result) {
        printf("Failed to malloc");
        #assert(0);
        exit(1);
    }
    return result;
}

func xcalloc(count: usize, size: usize): void* {
    result := calloc(count, size);
    if (!result) {
        printf("Failed to calloc");
        #assert(0);
        exit(1);
    }
    return result;
}

func is_power_2(x: int32): bool {
    return x != 0 && x & (x - 1) == 0;
}

func clamp(a: float, b: float, x: float): float {
    return (x < a) ? a :
           (x > b) ? b :
                     x;
}

func clampi(a: int32, b: int32, x: int32): int32 {
    return (x < a) ? a :
           (x > b) ? b :
                     x;
}

func clamp01(x: float): float {
    return clamp(0, 1, x);
}

func maxi(a: int32, b: int32): int32 {
    return (a > b) ? a : b;
}

func mini(a: int32, b: int32): int32 {
    return (a < b) ? a : b;
}

func max(a: float, b: float): float {
    return (a > b) ? a : b;
}

func min(a: float, b: float): float {
    return (a < b) ? a : b;
}

func min4(a: float, b: float, c: float, d: float): float {
    return min(min(a, b), min(c, d));
}

func max4(a: float, b: float, c: float, d: float): float {
    return max(max(a, b), max(c, d));
}

func float2_to_int2(x: float2): int2 {
    return { int32(x.x), int32(x.y) };
}

func int2_to_float2(x: int2): float2 {
    return { float(x.x), float(x.y) };
}

func mul2(a: float2, b: float2): float2 {
    return { a.x * b.x, a.y * b.y };
}

func div2(a: float2, b: float2): float2 {
    return { a.x / b.x, a.y / b.y };
}

func add2(a: float2, b: float2): float2 {
    return { a.x + b.x, a.y + b.y };
}

func sub2(a: float2, b: float2): float2 {
    return { a.x - b.x, a.y - b.y };
}

func mul2i(a: int2, b: int2): int2 {
    return { a.x * b.x, a.y * b.y };
}

func div2i(a: int2, b: int2): int2 {
    return { a.x / b.x, a.y / b.y };
}

func add2i(a: int2, b: int2): int2 {
    return { a.x + b.x, a.y + b.y };
}

func sub2i(a: int2, b: int2): int2 {
    return { a.x - b.x, a.y - b.y };
}

func dot2i(a: int2, b: int2): int32 {
    return a.x*b.x + a.y*b.y;
}

func distance_squared2i(a: int2, b: int2): int32 {
    d := int2 { a.x - b.x, a.y - b.y };
    return dot2i(d, d);
}

func distance2i(a: int2, b: int2): float {
    d := distance_squared2i(a, b);
    return sqrt(float(d));
}

func dot2(a: float2, b: float2): float {
    return a.x*b.x + a.y*b.y;
}

func distance_squared2(a: float2, b: float2): float {
    d := sub2(a, b);
    return dot2(d, d);
}

func distance2(a: float2, b: float2): float {
    d := distance_squared2(a, b);
    return sqrt(d);
}

func magnitude2(v: float2): float {
    return sqrt(dot2(v, v));
}

func magnitude2i(v: int2): float {
    return sqrt((:float)dot2i(v, v));
}

struct Color {
    r, g, b, a: float;
}

struct RGB8 {
    b, g, r: uint8;
    padding: uint8;
}

#static_assert(sizeof(RGB8) == 4)

struct Tex {
    size: int2;
    pixels: Color*;
    lod_levels: int;
    lods: Image*;
}

// Star types:
// *+.·˚⊹⋆✦✧✫✹✺　

struct StarType {
    id: int32;
    size: float2;
    tex: Tex;
}

enum StarTypes {
    StarType_Space = 0,
    StarType_BigSpace = 13,
    StarTypeCount
}

var star_types: StarType[StarTypeCount] = {};

struct StarsHeader {
    len: int64;
    cap: int64;
    data: Star[1];
}

struct Star {
    rect: Rect;
    type: StarType*;
    color: Color*;
    lod: int;
}

struct Starfield {
    stars: Star*;
    star_count: int32;
}

struct Rect {
    pos: float2; // center
    size: float2; // width, height
    rot: float2; // cos theta, sin theta
}

func stars_header(stars: Star*): StarsHeader* {
    return (:StarsHeader*)(((:char*)stars) - offsetof(StarsHeader, data));
}

func push_star(starfield: Starfield*, star: Star) {
    if (!starfield.stars) {
        initial_cap := 32;
        alloc_size := sizeof(Star)*initial_cap + sizeof(StarsHeader);
        header: StarsHeader* = xmalloc(alloc_size);
        memset(header, 0, alloc_size);
        header.cap = initial_cap;
        header.len = 0;
        starfield.stars = header.data;
    }

    header := stars_header(starfield.stars);

    if (header.len == header.cap) {
        new_cap := header.cap * 2;
        header = xrealloc(header, sizeof(Star)*new_cap + sizeof(StarsHeader));
        starfield.stars = header.data;
        header.cap = new_cap;

    }

    starfield.stars[header.len++] = star;
}

func consume_star(c: char const*, star: Star*): char const* {
    next := 0;
    if (*c == '\n') {
        c++;
    }

    if (*c == ' ') {
        #static_assert(StarType_Space == 0);
        star.type = star_types + StarType_Space;
        next = 1;
    } else if (*c == '*') {
        star.type = star_types + 1;
        next = 1;
    } else if (*c == '+') {
        star.type = star_types + 2;
        next = 1;
    } else if (*c == '.') {
        star.type = star_types + 3;
        next = 1;
    } else if (memcmp(c, "·", sizeof("·") - 1) == 0) {
        star.type = star_types + 4;
        next = sizeof("·") - 1;
    } else if (memcmp(c, "˚", sizeof("˚") - 1) == 0) {
        star.type = star_types + 5;
        next = sizeof("˚") - 1;
    } else if (memcmp(c, "⊹", sizeof("⊹") - 1) == 0) {
        star.type = star_types + 6;
        next = sizeof("⊹") - 1;
    } else if (memcmp(c, "⋆", sizeof("⋆") - 1) == 0) {
        star.type = star_types + 7;
        next = sizeof("⋆") - 1;
    } else if (memcmp(c, "✦", sizeof("✦") - 1) == 0) {
        star.type = star_types + 8;
        next = sizeof("✦") - 1;
    } else if (memcmp(c, "✧", sizeof("✧") - 1) == 0) {
        star.type = star_types + 9;
        next = sizeof("✧") - 1;
    } else if (memcmp(c, "✫", sizeof("✫") - 1) == 0) {
        star.type = star_types + 10;
        next = sizeof("✫") - 1;
    } else if (memcmp(c, "✹", sizeof("✹") - 1) == 0) {
        star.type = star_types + 11;
        next = sizeof("✹") - 1;
    } else if (memcmp(c, "✺", sizeof("✺") - 1) == 0) {
        star.type = star_types + 12;
        next = sizeof("✺") - 1;
    } else if (memcmp(c, "　", sizeof("　") - 1) == 0) {
        #static_assert(StarType_BigSpace == 13);
        star.type = star_types + StarType_BigSpace;
        next = sizeof("　") - 1;
    } else {
        #assert(0);
        star.type = 0;
        next = 1;
    }

    return c + next;
}

var random_state: uint32 = 1;
func random(): uint32 {
    random_state ^= random_state << 13;
    random_state ^= random_state >> 17;
    random_state ^= random_state << 5;
    return random_state;
}

const int_23_mask = 0b00000000_011111111111111111111111;
const int_23_reciprocal = 1. / int_23_mask;
func random01(): float {
    r := random() & int_23_mask;
    return r * int_23_reciprocal;
}

func random_unit_vector2(): float2 {
    theta := random01() * Tau;
    return { cos(theta), sin(theta) };
}

func create_starfield(starfield: char const*): Starfield {
    // todo: adjust height based on character, jitter
    result: Starfield = {};

    width := 0;
    height := 0;
    line_width := 0;
    star_count := 0;

    c := starfield;
    while (*c) {
        star: Star;
        c = consume_star(c, &star);

        if (star.type) {
            init_star_type(star.type);

            if (star.type.id == StarType_BigSpace) {
                line_width += 1;
            } else if (star.type.id != StarType_Space) {
                star_count++;

                star.rect.pos = { float(line_width), float(height) };
                xx := 1 + random01();
                star.rect.size = float2 { xx, xx };
                star.rect.rot = random_unit_vector2();

                push_star(&result, star);
            }
        }

        if (*c == '\n') {
            height += 6;
            width = maxi(width, line_width);
            line_width = 0;
            c++;
        } else {
            line_width += 2;
        }
    }

    width += 8;
    height += 4;

    R := maxi(width, height);
    x_pad := 4 + (R - width) / 2;
    y_pad := 4 + (R - height) / 2;

    result.star_count = star_count;
    for (i := 0; i < star_count; i++) {
        s := result.stars + i;
        s.rect.pos.x = (s.rect.pos.x + x_pad) / R;
        s.rect.pos.y = (s.rect.pos.y + y_pad) / R;
        s.rect.size.x = s.type.tex.size.x * s.rect.size.x / ImageSize.x;
        s.rect.size.y = s.type.tex.size.y * s.rect.size.y / ImageSize.y;
    }

    return result;
}


func draw_simple_star(buffer: Color*, size: int2) {
    center := div2(int2_to_float2(size), { 2., 2. });
    range := distance2({size.x / 2., 0}, center);
    radius := distance2({}, center);

    col := buffer;
    for (y := 0; y < size.y; y++) {
        for (x := 0; x < size.x; x++) {
            xy := int2_to_float2({x, y});
            c := distance2(xy, center) / radius;
            rel := sub2(xy, center);

            spike := clamp01(fabs(rel.x * rel.y) / range);
            color := (1 - c)*(1 - spike);

            col.a = color;
            if (c < range) {
                col.r = color * col.a;
                col.g = color * col.a;
                col.b = color * col.a;
            }

            col++;
        }
    }
}

func draw_outline(buffer: Color*, size: int2, color: Color) {
    for (i := 0; i < size.x; i++) {
        buffer[i] = color;
        buffer[i + (size.x - 1) * size.y] = color;
    }

    for (i := 0; i < size.y; i++) {
        buffer[i * size.x] = color;
        buffer[i * size.x + (size.x - 1)] = color;
    }
}

func make_tex(size: int2): Tex {
    #assert(is_power_2(size.x));
    #assert(is_power_2(size.y));
    // just interpolate for non-squares
    #assert(size.x == size.y);
    return Tex { size = size, pixels = xcalloc(size.x * size.y, sizeof(Color)) };
}

func free_tex(tex: Tex*) {
    #assert(tex.pixels);
    free(tex.pixels);
    tex.pixels = 0;
    tex.size = { 0, 0 };
    for (i := 1; i < tex.lod_levels; i++) {
        if (tex.lods[i].pixels) {
            free(tex.lods[i].pixels);
            tex.lods[i].pixels = 0;
        }
    }
}

func log2i(x: int): int {
    return int(SDL_MostSignificantBitIndex32(uint32(x)));
}

func compute_lod_level(dest_size: int2, target_size: float2, src_size: int2): float {
    step_x := src_size.x / (dest_size.x * target_size.x);
    step_y := src_size.y / (dest_size.y * target_size.y);
    return log2(max(step_x, step_y));
}

func generate_lods(tex: Tex*) {
    tex.lod_levels = maxi(0, log2i(tex.size.x) - 3);

    blurry_v := image_copy(&{tex.pixels, tex.size});
    blurry := &blurry_v;

    tex.lods = calloc(maxi(1, tex.lod_levels), sizeof(Image));
    tex.lods[0].size = tex.size;
    tex.lods[0].pixels = tex.pixels;

    size := tex.size;
    for (i := 1; i < tex.lod_levels; i++) {
        size = div2i(size, { 2, 2 });
        #assert(size.x >= 8);
        #assert(size.y >= 8);
        blur(blurry, 0.707);
        lod := tex.lods + i;
        *lod = make_image(size);

        for (it := pixel_iter_begin(lod, {}); pixel_iter_next(&it)) {
            *it.pixel = image_sample_nearest(blurry, it.pos);
        }
    }

    free_image(blurry);
}

func init_star_type(type: StarType*) {
    idx := (:int32)(type - star_types);
    #assert(idx >= 0);
    #assert(idx < StarTypeCount);

    if (type.tex.pixels) {
        #assert(type.size.x != 0.);
        #assert(type.size.y != 0.);
        #assert(type.tex.size.x != 0);
        #assert(type.tex.size.y != 0);
        return;
    }

    type.id = idx;

    switch (idx) {
        case 0:
            type.tex = make_tex({ 8, 8 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_outline(type.tex.pixels, type.tex.size, { 0, 1, 0, 0.5 });
        case 1: // *
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 2: // +
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 3: // .
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 4: // ·
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 5: // ˚
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 6: // ⊹
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 7: // ⋆
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 8: // ✦
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 9: // ✧
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 10: // ✫
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 11: // ✹
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 12: // ✺
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 13: // '　'
            type.tex = make_tex({ 8, 8 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_outline(type.tex.pixels, type.tex.size, { 1, 0, 0, 0.5 });
        default: {
            #assert(0);
        }
    }

    generate_lods(&type.tex);
}

func rotate(v: float2, cos_sin_theta: float2): float2 {
    if (cos_sin_theta.x && cos_sin_theta.y) {
        return float2 {
            v.x * cos_sin_theta.x - v.y * cos_sin_theta.y,
            v.x * cos_sin_theta.y + v.y * cos_sin_theta.x
        };
    }

    return v;
}

func inside_normal_rect(pos: float2): bool {
    return pos.x >= 0 && pos.x < 1
        && pos.y >= 0 && pos.y < 1;
}

func inside_rect(rect: Rect, pos: float2): bool {
    return inside_normal_rect(rect_relative(rect, pos));
}

func rect_relative(rect: Rect, abs_pos: float2): float2 {
    shift_pos := sub2(abs_pos, rect.pos);
    rot_pos := rotate(shift_pos, rect.rot);
    scaled_pos := div2(rot_pos, rect.size);
    result := add2(scaled_pos, { 0.5, 0.5 });
    return result;
}

func rect_absolute(rect: Rect, rel_pos: float2): float2 {
    centered_pos := sub2(rel_pos, { 0.5, 0.5 });
    scaled_pos := mul2(centered_pos, rect.size);
    rot_pos := rotate(scaled_pos, { rect.rot.x, -rect.rot.y });
    shift_pos := add2(rot_pos, rect.pos);
    return shift_pos;
}

func lerp(a: float, b: float, t: float): float {
    return (1 - t)*a + t*b;
}

func color_lerp(a: Color, b: Color, t: float): Color {
    return Color {
        lerp(a.r, b.r, t),
        lerp(a.g, b.g, t),
        lerp(a.b, b.b, t),
        lerp(a.a, b.a, t),
    };
}

func color_add(a: Color, b: Color): Color {
    return Color {
        a.r + b.r,
        a.g + b.g,
        a.b + b.b,
        a.a + b.a
    };
}

func color_sub(a: Color, b: Color): Color {
    return Color {
        a.r - b.r,
        a.g - b.g,
        a.b - b.b,
        a.a - b.a
    };
}

func color_mul(a: Color, b: Color): Color {
    return Color {
        a.r * b.r,
        a.g * b.g,
        a.b * b.b,
        a.a * b.a
    };
}

func color_mul1(a: Color, b: float): Color {
    return Color {
        a.r * b,
        a.g * b,
        a.b * b,
        a.a * b
    };
}

func blend(dest: Color, src: Color): Color {
    result := Color {
        src.r + (dest.r * (1. - src.a)),
        src.g + (dest.g * (1. - src.a)),
        src.b + (dest.b * (1. - src.a)),
        src.a + dest.a
    };
    return result;
}

struct Image {
    pixels: Color*;
    size: int2;
}

func is_zero(buf: void const*, len: usize): bool {
    p := (:char const*)buf;
    if (*p) {
        return false;
    }

    return memcmp(p + 1, buf, len - 1) == 0;
}

func all_rect(): Rect {
    return {
        pos = { 0.5, 0.5 },
        size = { 1, 1 },
        rot = { 1, 0 }
    };
}

struct PixelIter {
    image: Image*;
    start: int2;
    end: int2;
    rect: Rect;
    pixel_pos: int2;
    line_start: float2;

    dx: float2;
    dy: float2;
    lod_level: float;
    pos: float2;
    pixel: Color*;
}

func pixel_iter_begin(image: Image*, rect: Rect): PixelIter {
    iter: PixelIter = {};

    x_min := 0.;
    x_max := 1.;
    y_min := 0.;
    y_max := 1.;

    if (!is_zero(&rect, sizeof(rect))) {
        a := rect_absolute(rect, {0, 0});
        b := rect_absolute(rect, {1, 0});
        c := rect_absolute(rect, {0, 1});
        d := rect_absolute(rect, {1, 1});

        x_min = min4(a.x, b.x, c.x, d.x);
        x_max = max4(a.x, b.x, c.x, d.x);
        y_min = min4(a.y, b.y, c.y, d.y);
        y_max = max4(a.y, b.y, c.y, d.y);

        origin := rect_relative(rect, { 0, 0 });
        iter.dx = sub2(rect_relative(rect, { 1. / (image.size.x), 0 }), origin);
        iter.dy = sub2(rect_relative(rect, { 0, 1. / (image.size.y) }), origin);
    } else {
        rect = all_rect();
        iter.dx = { 1. / image.size.x, 0. };
        iter.dy = { 0., 1. / image.size.y };
    }

    iter.start.x = clampi(0, image.size.x - 1, int(x_min * image.size.x));
    iter.end.x   = clampi(0, image.size.x - 1, int(x_max * image.size.x));
    iter.start.y = clampi(0, image.size.y - 1, int(y_min * image.size.y));
    iter.end.y   = clampi(0, image.size.y - 1, int(y_max * image.size.y));

    iter.pixel_pos = { iter.start.x - 1, iter.start.y };
    iter.pos = rect_relative(rect, { float(iter.pixel_pos.x) / image.size.x, float(iter.pixel_pos.y) / image.size.y });
    iter.line_start = iter.pos;
    iter.rect = rect;
    iter.image = image;

    return iter;
}

func pixel_iter_next(it: PixelIter*): bool {
    it.pixel_pos.x++;

    for (; it.pixel_pos.y < it.end.y; it.pixel_pos.y++) {
        for (; it.pixel_pos.x < it.end.x; it.pixel_pos.x++) {
            it.pos = add2(it.pos, it.dx);

            if (inside_normal_rect(it.pos)) {
                it.pixel = it.image.pixels + (it.pixel_pos.x + it.pixel_pos.y*it.image.size.x);
                return true;
            }
        }

        it.line_start = add2(it.line_start, it.dy);
        it.pos = it.line_start;
        it.pixel_pos.x = it.start.x;
    }

    return false;
}

func draw_tex(dest: Image*, target: Rect, tex: Tex*) {
    lod := compute_lod_level(dest.size, target.size, tex.size);
    lod = clamp(0, float(tex.lod_levels - 1), lod);
    for (it := pixel_iter_begin(dest, target); pixel_iter_next(&it)) {
        rgba := tex_lookup_lod(tex, it.pos, lod);
        *it.pixel = blend(*it.pixel, rgba);
    }
}

func tex_lookup(tex: Tex*, pos: float2): Color {
    return image_sample_linear(tex.lods + 0, pos);
}

func tex_lookup_lod(tex: Tex*, pos: float2, lod: float): Color {
    #assert(lod < tex.lod_levels);
    lodi := int(lod);
    lodf := lod - lodi;
    a := image_sample_linear(tex.lods + lodi, pos);
    b := Color {};
    if (lodi + 1 < tex.lod_levels) {
        b = image_sample_linear(tex.lods + lodi + 1, pos);
    } else {
        #assert(lodf == 0);
    }
    return color_lerp(a, b, lodf);
}

func image_sample_linear(img: Image*, pos: float2): Color {
    pos.x *= img.size.x;
    pos.y *= img.size.y;

    vi := float2_to_int2(pos);
    vf := float2 { pos.x - vi.x, pos.y - vi.y };

    a := vi;
    b := add2i(vi, {1, 0});
    c := add2i(vi, {0, 1});
    d := add2i(vi, {1, 1});

    // Clamp? Black? Mirror? Wrap???
    a.x = clampi(0, img.size.x - 1, a.x);
    a.y = clampi(0, img.size.y - 1, a.y);
    b.x = clampi(0, img.size.x - 1, b.x);
    b.y = clampi(0, img.size.y - 1, b.y);
    c.x = clampi(0, img.size.x - 1, c.x);
    c.y = clampi(0, img.size.y - 1, c.y);
    d.x = clampi(0, img.size.x - 1, d.x);
    d.y = clampi(0, img.size.y - 1, d.y);

    A := img.pixels[a.x + a.y*img.size.x];
    B := img.pixels[b.x + b.y*img.size.x];
    C := img.pixels[c.x + c.y*img.size.x];
    D := img.pixels[d.x + d.y*img.size.x];

    AB := color_lerp(A, B, vf.x);
    CD := color_lerp(C, D, vf.x);
    ABCD := color_lerp(AB, CD, vf.y);

    return ABCD;
}

func image_sample_nearest(img: Image*, pos: float2): Color {
    if (pos.x < 0 || pos.x >= 1 || pos.y < 0 || pos.y >= 1) {
        return {};
    }
    p := int2 { int(pos.x * img.size.x), int(pos.y * img.size.y) };
    return img.pixels[p.x + p.y*img.size.x];
}

func image_fetch(img: Image*, pos: int2): Color {
    if (pos.x < 0 || pos.x >= img.size.x || pos.y < 0 || pos.y >= img.size.y) {
        return {};
    }

    return img.pixels[pos.x + pos.y*img.size.x];
}

func make_image(size: int2): Image {
    return Image {
        pixels = xcalloc(size.x*size.y, sizeof(Color)),
        size = size
    };
}

func free_image(img: Image*) {
    #assert(img.pixels);
    free(img.pixels);
    img.pixels = 0;
    img.size = { 0, 0 };
}

func image_clear(img: Image*) {
    memset(img.pixels, 0, img.size.x*img.size.y*sizeof(Color));
}

func image_copy(img: Image*): Image {
    #assert(img.pixels);
    result := make_image(img.size);
    memcpy(result.pixels, img.pixels, img.size.x*img.size.y*sizeof(Color));
    return result;
}

func image_copy_to(dest: Image*, src: Image*) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    memcpy(dest.pixels, src.pixels, src.size.x*src.size.y*sizeof(Color));
}

func blur_fetch(row: Color*, len: int, i: int): Color {
    if (i < 0 || i >= len) {
        return {};
    }

    return row[i];
}

func blur_calc_normalisation_factor(radius: float): float {
    // Computed by blurring a rect at a bunch of radiuses within [0.5, 16] and
    // fitting a least-squares curve to the energy loss. When you don't
    // interpolate lods you can see this actually adds a little brightness but
    // it's better than the dimming that happens without it.
    if (radius < 16) {
        return 1. / sqrt(1.85261426171087e-4 + radius*(-6.28416167917326e-3 + radius*(7.35416423963536e-2 + radius*(-2.28739004991180e-2))));
    } else {
        return 1. / 0.55;
    }
}


func blur_row(dest: Color*, src: Color*, len: int, radius: float) {
    #assert(radius > 0);
    r := int(radius);
    a := radius - r;

    r_rcp :=  1. / (2 * radius + 1);
    c_acc := color_mul1(src[r], a);

    for (i := 0; i < r; i++) {
        c_acc = color_add(c_acc, src[i]);
    }

    for (i := 0; i < len; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(blur_fetch(src, len, i+r), blur_fetch(src, len, i+r+1), a));
        c_acc = color_sub(c_acc, color_lerp(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
}

func blur_transpose_and_scale(dest: Color*, src: Color*, width: int, scale: float) {
    for (i := 0; i < width; i++) {
        *dest = color_mul1(*src, scale);
        dest += width;
        src++;
    }
}

func blur(img: Image*, radius: float) {
    blur_to(img, img, radius);
}

func blur_to(dest: Image*, src: Image*, radius: float) {
    #assert(dest.size.x == src.size.x);
    #assert(dest.size.y == src.size.y);

    temp := make_image({src.size.y, src.size.x});
    scratch: Color* = xcalloc(src.size.x, sizeof(Color));
    factor := blur_calc_normalisation_factor(radius);

    for (y := 0; y < src.size.y; y++) {
        row_src := src.pixels + y*src.size.x;
        row_dest := dest.pixels + y*dest.size.x;
        blur_row(scratch, row_src, src.size.x, radius);
        blur_row(row_dest, scratch, src.size.x, radius);
        blur_row(scratch, row_dest, src.size.x, radius);
        blur_transpose_and_scale(temp.pixels + y, scratch, src.size.x, factor);
    }

    for (y := 0; y < temp.size.y; y++) {
        row := temp.pixels + y*temp.size.x;
        blur_row(scratch, row, temp.size.x, radius);
        blur_row(row, scratch, temp.size.x, radius);
        blur_row(scratch, row, temp.size.x, radius);
        blur_transpose_and_scale(dest.pixels + y, scratch, temp.size.y, factor);
    }

    free_image(&temp);
}


func image_to_rgb8(dest: RGB8*, size: int2, src: Image*) {
    #assert(src.size.x == size.x);
    #assert(src.size.y == size.y);
    src_end := src.pixels + src.size.x*src.size.y;
    for (src_it := src.pixels; src_it != src_end; src_it++) {
        *dest = color_to_rgb8(*src_it);
        dest++;
    }
}


func srgb(val: float): float {
    val = clamp01(val);

    if (val <= 0.0031308) {
        return val * 12.92;
    }

    return 1.055 * pow(val, 1./2.4) - 0.055;
}

func color_to_rgb8(color: Color): RGB8 {
    result := RGB8 {
        r = uint8(srgb(color.r) * 255.),
        g = uint8(srgb(color.g) * 255.),
        b = uint8(srgb(color.b) * 255.),
    };
    return result;
}

func draw_starfield(image: Image*, starfield: Starfield*) {
    for (i := 0; i < starfield.star_count; i++) {
        star := starfield.stars + i;
        star.rect.rot = rotate(star.rect.rot, { cos(0.05), sin(0.05)});
        r := star.rect;
        r.size.x *= 0.5*cos(float(time_now())) + 0.6;
        r.size.y *= 0.5*cos(float(time_now())) + 0.6;
        draw_tex(image, r, &star.type.tex);
    }
}

func time_now(): double {
    ticks := SDL_GetPerformanceCounter() - app.time.sdl_start_ticks;
    return double(ticks) / double(app.time.ticks_per_sec);
}

func main(argc: int, argv: char**): int {
    if (!app_init()) {
        print_and_clear_error();
        return 1;
    }

    app.window.size = ImageSize;
    app_update();

    printf("Platform: %s\n", app.platform);
    printf("Display: %d x %d, %d Hz, %.2f DPI\n", app.display.size.x, app.display.size.y, app.display.rate, app.display.dpi);

    surface := SDL_GetWindowSurface(app.window.sdl);
    renderer := SDL_CreateSoftwareRenderer(surface);
    #assert(surface.format.format == SDL_PIXELFORMAT_RGB888);
    #assert(surface.format.BitsPerPixel == 32);

    starfield_text :="""
✺   　　 　　 ·   ⊹
 *  ⋆ 　　　  ✧  *
  　　　　　　　.  　
 +  *　  　* 　　. 　 ⋆
  ✫ 　　  +
""";

    starfield := create_starfield(starfield_text);

    min_t := 1000.; //todo float max
    max_t := 0.;
    sum_t := 0.;
    n_t := 0;


    image := make_image({ surface.w, surface.h });
    // blurred := make_image({ surface.w, surface.h });
    while (app_update()) {
        if (app.error) {
            print_and_clear_error();
        }

        image_clear(&image);

        t0 := time_now();
        t0f := float(t0);
        draw_starfield(&image, &starfield);
        draw_outline(image.pixels, image.size, {1, 0, 1, 1});

        // blur_to(&blurred, &image,  3);
        // for (it := pixel_iter_begin(&image, {}); pixel_iter_next(&it)) {
        //     bp := image_fetch(&blurred, it.pixel_pos);
        //     *it.pixel = color_add(*it.pixel, bp);
        // }
        image_to_rgb8((:RGB8*)surface.pixels,  { surface.w, surface.h }, &image);
        t1 := time_now();

        t := float((t1 - t0)*1000);
        min_t = min(t, min_t);
        max_t = max(t, max_t);
        sum_t += t;
        n_t++;
        if (n_t & 31 == 0) {
            printf("min %.2fms max %.2fms avg %.2fms\n", min_t, max_t, sum_t/n_t);
            sum_t = 0;
            n_t = 0;
        }

        SDL_UpdateWindowSurface(app.window.sdl);

        fflush(stdout);
        SDL_Delay(10);
    }

    return 0;
}