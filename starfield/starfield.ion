import libc { ... }
import sdl { ... }
import noir { ... }

@foreign
func isnan(f: float): bool;

#foreign(header = "<xmmintrin.h>")
@foreign
func _MM_SET_FLUSH_ZERO_MODE(mask: uint32);
@foreign
var _MM_FLUSH_ZERO_ON: uint32;

var ImageSize: int2 const = { 500, 500 };

func xrealloc(mem: void*, size: usize): void* {
    result := realloc(mem, size);
    if (!result) {
        printf("Failed to realloc");
        #assert(0);
        exit(1);
    }
    return result;
}

func xmalloc(size: usize): void* {
    result := malloc(size);
    if (!result) {
        printf("Failed to malloc");
        #assert(0);
        exit(1);
    }
    memset(result, 0, size);
    return result;
}

func xcalloc(count: usize, size: usize): void* {
    result := calloc(count, size);
    if (!result) {
        printf("Failed to calloc");
        #assert(0);
        exit(1);
    }
    return result;
}

struct Color {
    r, g, b, a: float;
}

struct RGB8 {
    b, g, r: uint8;
    padding: uint8;
}

#static_assert(sizeof(RGB8) == 4)

struct Tex {
    pixels: Color*;
    size: int2;
    lod_levels: int;
}

func make_tex(size: int2): Tex {
    #assert(is_power_2(size.x));
    #assert(size.x == size.y);
    // Allocate space for lods as well.
    pixels := xcalloc(size.x*size.y*4/3, sizeof(Color));
    return Tex {
        size = size,
        lod_levels = 1,
        pixels = pixels
    };
}

func free_tex(tex: Tex*) {
    #assert(tex.pixels);
    free(tex.pixels);
    tex.pixels = 0;
    tex.size = { 0, 0 };
}

func compute_lod_level(dest_size: int2, target_size: float2, src_size: int2): float {
    step_x := src_size.x / (dest_size.x * target_size.x);
    step_y := src_size.y / (dest_size.y * target_size.y);
    return max(0, log2(max(step_x, step_y)));
}

func generate_lods(tex: Tex*) {
    #assert(tex.size.x == tex.size.y);
    tex.lod_levels = maxi(1, log2i(tex.size.x));

    blurry := image_copy(&{tex.pixels, tex.size});

    size := tex.size.x;
    for (i := 1; i < tex.lod_levels; i++) {
        #assert(size >= 1);
        blurry_subrect := Image { blurry.pixels, { size, size }};
        prev_lod := tex_get_lod(tex, i - 1);
        blur_to(&blurry_subrect, &prev_lod, .707);
        lod := tex_get_lod(tex, i);

        for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
            #assert(image_sample_nearest(&lod, it.pos).r == it.pixel.r);
            *it.pixel = image_sample_nearest(&blurry_subrect, it.pos);
        }

        size /= 2;
    }

    free_image(&blurry);
}

func tex_get_lod(tex: Tex*, lod: int): Image {
    #assert(lod >= 0);
    if (lod >= tex.lod_levels) {
        return {};
    }

    lod_size := tex.size.x >> lod;
    pixels := tex.pixels + (tex.size.x*tex.size.x - lod_size*lod_size)*4/3;

    return Image { pixels = pixels, size = { lod_size, lod_size }};
}

func tex_lookup(tex: Tex*, pos: float2): Color {
    return image_sample_linear(&{tex.pixels, tex.size}, pos);
}

func tex_lookup_lod(tex: Tex*, pos: float2, lod: float): Color {
    lodi := int(lod);
    lodf := lod - lodi;
    a_lod := tex_get_lod(tex, lodi);
    b_lod := tex_get_lod(tex, lodi + 1);
    a := image_sample_linear(&a_lod, pos);
    if (lodf > 0.00015) { // ~srgb(1/255)/2
        b := image_sample_linear(&b_lod, pos);
        return color_lerp(a, b, lodf);
    }

    return a;
}

// Star types:
// *+.·˚⊹⋆✦✧✫✹✺　

struct StarType {
    id: int32;
    size: float2;
    tex: Tex;
}

enum StarTypes {
    StarType_Space = 0,
    StarType_BigSpace = 13,
    StarTypeCount
}

var star_types: StarType[StarTypeCount] = {};

struct StarsHeader {
    len: int64;
    cap: int64;
    data: Star[1];
}

struct Star {
    rect: Rect;
    type: StarType*;
    color: Color;
}

struct Starfield {
    stars: Star*;
    star_count: int32;
}

struct Rect {
    pos: float2; // center
    size: float2; // width, height
    rot: float2; // cos theta, sin theta
}

func stars_header(stars: Star*): StarsHeader* {
    return (:StarsHeader*)(((:char*)stars) - offsetof(StarsHeader, data));
}

func push_star(starfield: Starfield*, star: Star) {
    if (!starfield.stars) {
        initial_cap := 32;
        alloc_size := sizeof(Star)*initial_cap + sizeof(StarsHeader);
        header: StarsHeader* = xmalloc(alloc_size);
        memset(header, 0, alloc_size);
        header.cap = initial_cap;
        header.len = 0;
        starfield.stars = header.data;
    }

    header := stars_header(starfield.stars);

    if (header.len == header.cap) {
        new_cap := header.cap * 2;
        header = xrealloc(header, sizeof(Star)*new_cap + sizeof(StarsHeader));
        starfield.stars = header.data;
        header.cap = new_cap;
    }

    init_star_type(star.type);
    starfield.stars[header.len++] = star;
}

func stars_len(starfield: Starfield*): int {
    return (:int)stars_header(starfield.stars).len;
}

func consume_star(c: char const*, star: Star*): char const* {
    next := 0;
    if (*c == '\n') {
        c++;
    }

    if (*c == ' ') {
        #static_assert(StarType_Space == 0);
        star.type = star_types + StarType_Space;
        next = 1;
    } else if (*c == '*') {
        star.type = star_types + 1;
        next = 1;
    } else if (*c == '+') {
        star.type = star_types + 2;
        next = 1;
    } else if (*c == '.') {
        star.type = star_types + 3;
        next = 1;
    } else if (memcmp(c, "·", sizeof("·") - 1) == 0) {
        star.type = star_types + 4;
        next = sizeof("·") - 1;
    } else if (memcmp(c, "˚", sizeof("˚") - 1) == 0) {
        star.type = star_types + 5;
        next = sizeof("˚") - 1;
    } else if (memcmp(c, "⊹", sizeof("⊹") - 1) == 0) {
        star.type = star_types + 6;
        next = sizeof("⊹") - 1;
    } else if (memcmp(c, "⋆", sizeof("⋆") - 1) == 0) {
        star.type = star_types + 7;
        next = sizeof("⋆") - 1;
    } else if (memcmp(c, "✦", sizeof("✦") - 1) == 0) {
        star.type = star_types + 8;
        next = sizeof("✦") - 1;
    } else if (memcmp(c, "✧", sizeof("✧") - 1) == 0) {
        star.type = star_types + 9;
        next = sizeof("✧") - 1;
    } else if (memcmp(c, "✫", sizeof("✫") - 1) == 0) {
        star.type = star_types + 10;
        next = sizeof("✫") - 1;
    } else if (memcmp(c, "✹", sizeof("✹") - 1) == 0) {
        star.type = star_types + 11;
        next = sizeof("✹") - 1;
    } else if (memcmp(c, "✺", sizeof("✺") - 1) == 0) {
        star.type = star_types + 12;
        next = sizeof("✺") - 1;
    } else if (memcmp(c, "　", sizeof("　") - 1) == 0) {
        #static_assert(StarType_BigSpace == 13);
        star.type = star_types + StarType_BigSpace;
        next = sizeof("　") - 1;
    } else {
        #assert(0);
        star.type = 0;
        next = 1;
    }

    init_star_type(star.type);
    return c + next;
}

// https://en.wikipedia.org/wiki/Stellar_classification#cite_note-9
// https://en.wikipedia.org/wiki/File:TernaryColorTmap.PNG
var star_colors: Color[] = {
    { 0xff / 255., 0x01 / 255., 0.,          1. },
    { 0xff / 255., 0x0f / 255., 0.,          1. },
    { 0xff / 255., 0x29 / 255., 0x03 / 255., 1. },
    { 0xff / 255., 0x49 / 255., 0x0d / 255., 1. },
    { 0xff / 255., 0x6a / 255., 0x1f / 255., 1. },
    { 0xff / 255., 0xa6 / 255., 0x59 / 255., 1. },
    { 0xff / 255., 0xc0 / 255., 0x7f / 255., 1. },
    { 0xff / 255., 0xd8 / 255., 0xa8 / 255., 1. },
    { 0xff / 255., 0xed / 255., 0xd3 / 255., 1. },
    { 1,           1,           1,           1. },
    { 0xdb / 255., 0xe9 / 255., 0xff / 255., 1. },
    { 0x8e / 255., 0xb4 / 255., 0xff / 255., 1. },
    { 0x6e / 255., 0x9a / 255., 0xff / 255., 1. },
    { 0x45 / 255., 0x73 / 255., 0xff / 255., 1. },
    { 0x2f / 255., 0x5c / 255., 0xff / 255., 1. },
};
const star_color_count = (sizeof(star_colors)/sizeof(Color));

func mod(x: float, m: float): float {
    if (x < 0) {
        x = m - x;
    }
    r := x / m;
    q := r - int(r);
    p := q * m;
    return p;
}

func wrap(x: float, m: float): float {
    y := mod(x, m * 2);
    if (y > m) {
        y -= (y - m);
    }
    return y;
}

func random_star_color(alpha: float): Color {
    offset := 8;
    r := offset + random_normal() * (star_color_count / 7);
    x := wrap(r, star_color_count - 1);
    #assert(x >= 0 && x < star_color_count);

    xi := int(x);
    xf := x - xi;
    color := color_lerp((star_colors[xi]), (star_colors[xi + 1]), xf);
    color.a = random01() * (float(xi) / star_color_count) * alpha;
    return color;
}

func create_starfield(starfield: char const*): Starfield {
    // todo: adjust height based on character, jitter
    result: Starfield = {};

    width := 0;
    height := 0;
    line_width := 0;
    star_count := 0;

    c := starfield;
    while (*c) {
        star: Star;
        c = consume_star(c, &star);

        if (star.type) {
            if (star.type.id == StarType_BigSpace) {
                line_width += 1;
            } else if (star.type.id != StarType_Space) {
                star_count++;

                star.rect.pos = { float(line_width) + random01()*0.5-.25, float(height) + random01()*0.5-.25 };
                x := 1 + square(random_normal()) / 10.;
                star.rect.size = float2 { x, x };
                star.rect.rot = random_unit_vector2();
                star.color = random_star_color(1);

                push_star(&result, star);
            }
        }

        if (*c == '\n') {
            height += 6;
            width = maxi(width, line_width);
            line_width = 0;
            c++;
        } else {
            line_width += 2;
        }
    }

    width += 8;
    height += 4;

    R := maxi(width, height);
    x_pad := 4 + (R - width) / 2;
    y_pad := 4 + (R - height) / 2;

    for (i := 0; i < stars_len(&result); i++) {
        s := result.stars + i;
        s.rect.pos.x = (s.rect.pos.x + x_pad) / R;
        s.rect.pos.y = (s.rect.pos.y + y_pad) / R;
        s.rect.size.x = s.type.tex.size.x * s.rect.size.x / ImageSize.x;
        s.rect.size.y = s.type.tex.size.y * s.rect.size.y / ImageSize.y;
    }

    star_count_noise := make_tex({ 8, 8 });
    density := square(random_normal() + 2);
    n := 0;
    for (it := pixel_iter_begin_tex(&star_count_noise, {}); pixel_iter_next(&it)) {
        // TODO: Single channel texture!
        it.pixel.r = (:float)random_poisson(fabs(density + random_normal()));
        n++;
    }
    #assert(n == 64);

    tiles := 25;
    w := 1. / tiles;
    background_star_size := 0.005;
    xy := float2 { w / 2., w / 2. };
    for (i := 0; i < tiles; i++) {
        for (j := 0; j < tiles; j++) {
            count := (:int)max(1., tex_lookup(&star_count_noise, xy).r);
            for (k := 0; k < count; k++) {
                size := max(2. / ImageSize.x, random_normal()*background_star_size);

                push_star(&result, {
                    rect = {
                        pos = add2(xy, {(random01() - 0.5) * w, (random01() - 0.5) * w}),
                        size = { size, size },
                        rot = {}
                    },
                    type = star_types + 1,
                    color = random_star_color(size)
                });
            }

            xy.x += w;
        }

        xy.x = w / 2;
        xy.y += w;
    }

    free_tex(&star_count_noise);

    result.star_count = stars_len(&result);
    return result;
}


func draw_simple_star(buffer: Color*, size: int2) {
    buffer[size.x/2 + size.x*size.y/2] = { 64, 64, 64, 1 };
}

func draw_outline(buffer: Color*, size: int2, color: Color) {
    for (i := 0; i < size.x; i++) {
        buffer[i] = color;
        buffer[i + (size.x - 1) * size.y] = color;
    }

    for (i := 0; i < size.y; i++) {
        buffer[i * size.x] = color;
        buffer[i * size.x + (size.x - 1)] = color;
    }
}

func init_star_type(type: StarType*) {
    idx := (:int32)(type - star_types);
    #assert(idx >= 0);
    #assert(idx < StarTypeCount);

    if (type.tex.pixels) {
        #assert(type.size.x != 0.);
        #assert(type.size.y != 0.);
        #assert(type.tex.size.x != 0);
        #assert(type.tex.size.y != 0);
        return;
    }

    type.id = idx;

    switch (idx) {
        case 0:
            type.tex = make_tex({ 8, 8 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_outline(type.tex.pixels, type.tex.size, { 0, 1, 0, 0.5 });
        case 1: // *
            type.tex = make_tex({ 32, 32});
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 2: // +
            type.tex = make_tex({ 32, 32});
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 3: // .
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 4: // ·
            type.tex = make_tex({ 32, 32 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 5: // ˚
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 6: // ⊹
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 7: // ⋆
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 8: // ✦
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 9: // ✧
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 10: // ✫
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 11: // ✹
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 12: // ✺
            type.tex = make_tex({ 64, 64 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_simple_star(type.tex.pixels, type.tex.size);
        case 13: // '　'
            type.tex = make_tex({ 8, 8 });
            type.size = div2(int2_to_float2(type.tex.size), int2_to_float2(ImageSize));
            draw_outline(type.tex.pixels, type.tex.size, { 1, 0, 0, 0.5 });
        default: {
            #assert(0);
        }
    }

    generate_lods(&type.tex);
}

func all_rect(): Rect {
    return {
        pos = { 0.5, 0.5 },
        size = { 1, 1 },
        rot = { 1, 0 }
    };
}

func rotate(v: float2, cos_sin_theta: float2): float2 {
    if (cos_sin_theta.x && cos_sin_theta.y) {
        return float2 {
            v.x * cos_sin_theta.x - v.y * cos_sin_theta.y,
            v.x * cos_sin_theta.y + v.y * cos_sin_theta.x
        };
    }

    return v;
}

func inside_normal_rect(pos: float2): bool {
    return pos.x >= 0 && pos.x < 1
        && pos.y >= 0 && pos.y < 1;
}

func inside_rect(rect: Rect, pos: float2): bool {
    return inside_normal_rect(rect_relative(rect, pos));
}

func rect_relative(rect: Rect, abs_pos: float2): float2 {
    shift_pos := sub2(abs_pos, rect.pos);
    rot_pos := rotate(shift_pos, rect.rot);
    scaled_pos := div2(rot_pos, rect.size);
    result := add2(scaled_pos, { 0.5, 0.5 });
    return result;
}

func rect_absolute(rect: Rect, rel_pos: float2): float2 {
    centered_pos := sub2(rel_pos, { 0.5, 0.5 });
    scaled_pos := mul2(centered_pos, rect.size);
    rot_pos := rotate(scaled_pos, { rect.rot.x, -rect.rot.y });
    shift_pos := add2(rot_pos, rect.pos);
    return shift_pos;
}

func lerp(a: float, b: float, t: float): float {
    return (1 - t)*a + t*b;
}

func color_lerp(a: Color, b: Color, t: float): Color {
    return Color {
        lerp(a.r, b.r, t),
        lerp(a.g, b.g, t),
        lerp(a.b, b.b, t),
        lerp(a.a, b.a, t),
    };
}

func color_add(a: Color, b: Color): Color {
    return Color {
        a.r + b.r,
        a.g + b.g,
        a.b + b.b,
        a.a + b.a
    };
}

func color_sub(a: Color, b: Color): Color {
    return Color {
        a.r - b.r,
        a.g - b.g,
        a.b - b.b,
        a.a - b.a
    };
}

func color_mul(a: Color, b: Color): Color {
    return Color {
        a.r * b.r,
        a.g * b.g,
        a.b * b.b,
        a.a * b.a
    };
}

func color_mul1(a: Color, b: float): Color {
    return Color {
        a.r * b,
        a.g * b,
        a.b * b,
        a.a * b
    };
}

func blend(dest: Color, src: Color): Color {
    result := Color {
        src.r + (dest.r * (1. - src.a)),
        src.g + (dest.g * (1. - src.a)),
        src.b + (dest.b * (1. - src.a)),
        src.a + (dest.a * (1. - src.a))
    };
    return result;
}

func is_zero(buf: void const*, len: usize): bool {
    p := (:char const*)buf;
    if (*p) {
        return false;
    }

    return memcmp(p + 1, buf, len - 1) == 0;
}

func srgb(val: float): float {
    #assert(!isnan(val));
    val = clamp01(val);

    if (val <= 0.0031308) {
        return val * 12.92;
    }

    return 1.055 * pow(val, 1./2.4) - 0.055;
}

func color_to_rgb8(color: Color): RGB8 {
    result := RGB8 {
        r = uint8(srgb(color.r) * 255.),
        g = uint8(srgb(color.g) * 255.),
        b = uint8(srgb(color.b) * 255.),
    };
    return result;
}

func draw_starfield(dest: Image*, starfield: Starfield*) {
    for (i := starfield.star_count - 1; i >= 0; i--) {
        star := starfield.stars + i;
        draw_tex_multiply(dest, star.rect, &star.type.tex, star.color);
    }
}

func time_now(): double {
    ticks := SDL_GetPerformanceCounter() - app.time.sdl_start_ticks;
    return double(ticks) / double(app.time.ticks_per_sec);
}

func main(argc: int, argv: char**): int {
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);

    if (!app_init()) {
        print_and_clear_error();
        return 1;
    }

    app.window.size = ImageSize;
    app_update();

    printf("Platform: %s\n", app.platform);
    printf("Display: %d x %d, %d Hz, %.2f DPI\n", app.display.size.x, app.display.size.y, app.display.rate, app.display.dpi);

    surface := SDL_GetWindowSurface(app.window.sdl);
    renderer := SDL_CreateSoftwareRenderer(surface);
    #assert(surface.format.format == SDL_PIXELFORMAT_RGB888);
    #assert(surface.format.BitsPerPixel == 32);

    starfield_text :="""
✺   　　 　　 ·   ⊹
 *  ⋆ 　　　  ✧  *
  　　　　　　　.  　
 +  *　  　* 　　. 　 ⋆
  ✫ 　　  +
""";


    starfield := create_starfield(starfield_text);

    min_t := 1000.; //todo float max
    max_t := 0.;
    sum_t := 0.;
    n_t := 0;
    t_reset := time_now();

    image := make_image({ surface.w, surface.h });
    blurred := make_image({ surface.w, surface.h });
    blurred2 := make_image({ surface.w, surface.h });
    while (app_update()) {
        if (app.error) {
            print_and_clear_error();
        }

        if ( !n_t || app.mouse.left_button.pressed) {
            image_clear(&image);

            t0 := time_now();
            t0f := float(t0);
            draw_starfield(&image, &starfield);
            diffraction(&image, 0.1, 16, mul2({sqrt(2), sqrt(2)}, random_unit_vector2()));
            blur_to(&blurred, &image, 1);
            blur_to(&blurred2, &image, 1.5);
            for (it := pixel_iter_begin(&image, {}); pixel_iter_next(&it)) {
                bp := image_fetch(&blurred, it.pixel_pos);
                mbp := color_mul(*it.pixel, bp);
                xbp := color_lerp(bp, mbp, 0.95);

                bp2 := image_fetch(&blurred2, it.pixel_pos);
                mbp2 := color_mul(*it.pixel, bp2);
                xbp2 := color_lerp(bp2, mbp2, .75);
                *it.pixel = color_add(*it.pixel, color_add(xbp, xbp2));
            }
            image_to_rgb8((:RGB8*)surface.pixels,  { surface.w, surface.h }, &image);
            t1 := time_now();

            t := float((t1 - t0)*1000);
            min_t = min(t, min_t);
            max_t = max(t, max_t);
            sum_t += t;
            n_t++;

            if (app.mouse.left_button.pressed) {
                printf("min %.2fms max %.2fms avg %.2fms\n", min_t, max_t, sum_t/n_t);

                free(stars_header(starfield.stars));
                starfield = create_starfield(starfield_text);
                t_reset = t0;
            }
        }

        SDL_UpdateWindowSurface(app.window.sdl);

        fflush(stdout);
        SDL_Delay(10);
    }

    return 0;
}