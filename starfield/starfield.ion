import libc { ... }
import sdl { ... }
import noir { ... }

#foreign(header = "<SDL_bits.h>")

@foreign
func isnan(f: float): bool;

var ImageSize: int2 const = { 500, 500 };

func xrealloc(mem: void*, size: usize): void* {
    result := realloc(mem, size);
    if (!result) {
        printf("Failed to realloc");
        #assert(!"Bad realloc");
        exit(1);
    }
    return result;
}

func xmalloc(size: usize): void* {
    result := malloc(size);
    if (!result) {
        printf("Failed to malloc");
        #assert(!"Bad malloc");
        exit(1);
    }
    memset(result, 0, size);
    return result;
}

func xcalloc(count: usize, size: usize): void* {
    result := calloc(count, size);
    if (!result) {
        printf("Failed to calloc");
        #assert(!"Bad calloc");
        exit(1);
    }
    return result;
}

func is_zero(buf: void const*, len: usize): bool {
    p := (:char const*)buf;
    if (*p) {
        return false;
    }

    return memcmp(p + 1, buf, len - 1) == 0;
}

func is_equal(a: void const*, b: void const*, len: usize): bool {
    return memcmp(a, b, len) == 0;
}

struct BufHeader {
    len: ssize;
    cap: ssize;
    data: uint8[1];
}

func buf_header(buf: void*): BufHeader* {
    return buf ? (:BufHeader*)((:uint8*)buf - offsetof(BufHeader, data)) : 0;
}

func buf_len(buf: void*): ssize {
    return buf ? buf_header(buf).len : 0;
}

func buf_cap(buf: void*): ssize {
    return buf ? buf_header(buf).cap : 0;
}

func buf_free(buf: void*) {
    h := buf_header(buf);
    if (h) {
        free(h);
    }
}

func buf_fit(buf: void**, len: ssize) {
    #assert(buf);
    #assert(len);

    if (!*buf) {
        initial_cap := len > 1024 ? len : len * 32;
        alloc_size := initial_cap + sizeof(BufHeader);
        header: BufHeader* = xmalloc(alloc_size);
        header.cap = initial_cap;
        header.len = 0;
        *buf = header.data;
    }

    header := buf_header(*buf);

    if (header.len + len > header.cap) {
        new_cap := header.cap * 2;
        header = xrealloc(header, len*new_cap + sizeof(BufHeader));
        header.cap = new_cap;
        *buf = header.data;
    }
}

func buf_push(buf: void**, data: void*, len: ssize): void* {
    buf_fit(buf, len);
    #assert(*buf);
    header := buf_header(*buf);
    slot := header.data + header.len;
    memcpy(slot, data, len);
    header.len += len;
    #assert(header.len <= header.cap);
    return slot;
}

func buf_pop(buf: void*, len: ssize): void* {
    header := buf_header(buf);
    if (header.len > 0) {
        #assert(header.len >= len);
        result := header.data + (header.len - len);
        header.len -= len;
        return result;
    }

    return 0;
}

func buf_u32_push(buf: uint32**, v: uint32) {
    buf_push((:void**)buf, &v, sizeof(v));
}

func buf_u32_pop(buf: uint32*): uint32 {
    p: uint32* = buf_pop(buf, sizeof(uint32));
    return p ? *p : 0;
}

func hash(p: void*, len: ssize): usize {
    h := 0xcbf29ce484222325u;
    b := (:uint8*)p;
    for (i := 0; i < len; i++) {
        h ^= b[i];
        h *= 1099511628211u;
    }
    return h;
}

func bad_hash_int2(p: int2): usize {
    h := (((0xcbf29ce484222325u ^ p.x) * 1099511628211u) ^ p.y) * 1099511628211u;
    return h;
}

func bad_hash_int2_u32(p: int2): uint32 {
    h := bad_hash_int2(p);
    return uint32((h >> 32) ^ h);
}

union Color {
    struct {
        r: float;
        g: float;
        b: float;
        a: float;
    }
    xmm: float4;
}

struct RGB8 {
    b, g, r: uint8;
    padding: uint8;
} #static_assert(sizeof(RGB8) == 4)

struct Tex {
    pixels: Color*;
    size: int2;
    lod_levels: int;
}

struct Rect {
    pos: float2; // center
    size: float2; // width, height
    rot: float2; // cos theta, sin theta
}

func make_tex(size: int2): Tex {
    #assert(is_power_2(size.x));
    #assert(size.x == size.y);
    // Allocate space for lods as well.
    pixels := xcalloc(size.x*size.y*4, sizeof(Color));
    return Tex {
        size = size,
        lod_levels = 1,
        pixels = pixels
    };
}

func free_tex(tex: Tex*) {
    #assert(tex.pixels);
    free(tex.pixels);
    tex.pixels = 0;
    tex.size = { 0, 0 };
}

func make_tex_from_image(img: Image*): Tex {
    tex := make_tex(img.size);
    image_copy_to(&{tex.pixels, tex.size}, img);
    // Note: no mip mapping or premultiplied alpha.
    return tex;
}

func compute_lod_level(dest_size: int2, target_size: float2, src_size: int2): float2 {
    // Todo: don't take into account rotation of the target rect.
    step_x := fabs(src_size.x / (dest_size.x * target_size.x));
    step_y := fabs(src_size.y / (dest_size.y * target_size.y));
    return { max(0, log2(step_x)), max(0, log2(step_y)) };
}

// Axis-aligned anisotropic filtering
func generate_lods(tex: Tex*) {
    #assert(tex.size.x == tex.size.y);
    tex.lod_levels = maxi(1, log2i(tex.size.x) + 1);

    blurry := image_copy(&{tex.pixels, tex.size});

    size := tex.size;
    for (i := 0; i < tex.lod_levels; i++) {
        #assert(size.x >= 1);
        #assert(size.y >= 1);

        if (i > 0) {
            // Square pyramid
            prev_lod := tex_get_lod(tex, { i - 1, i - 1 });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_to(&blurry_subrect, &prev_lod, .707);
            lod := tex_get_lod(tex, { i, i });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_linear(&blurry_subrect, it.pos);
                #assert(!color_nan(*it.pixel));
            }
        }

        for (j := i + 1; j < tex.lod_levels; j++) {
            prev_lod := tex_get_lod(tex, { j - 1, i });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_horizontal(&blurry_subrect, &prev_lod, 0.5);
            lod := tex_get_lod(tex, { j, i });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_linear(&blurry_subrect, it.pos);
                #assert(!color_nan(*it.pixel));
            }
        }

        for (k := i + 1; k < tex.lod_levels; k++) {
            prev_lod := tex_get_lod(tex, { i, k - 1 });
            blurry_subrect := Image { blurry.pixels, prev_lod.size };

            blur_vertical(&blurry_subrect, &prev_lod, 0.5);
            lod := tex_get_lod(tex, { i, k });

            for (it := pixel_iter_begin(&lod, {}); pixel_iter_next(&it)) {
                #assert(is_zero(it.pixel, sizeof(Color)));
                *it.pixel = image_sample_linear(&blurry_subrect, it.pos);
                #assert(!color_nan(*it.pixel));
            }
        }
    }

    free_image(&blurry);
}

func tex_premultiply_alpha(tex: Tex*) {
    for (it := pixel_iter_begin_tex(tex, {}); pixel_iter_next(&it)) {
        *it.pixel = color_premultiply(*it.pixel);
    }
}

func tex_preprocess(tex: Tex*) {
    tex_premultiply_alpha(tex);
    generate_lods(tex);
}

func tex_poke(tex: Tex*, pos: int2, val: Color) {
    #assert(tex.lod_levels == 1);

    pos.x = clampi(0, tex.size.x - 1, pos.x);
    pos.y = clampi(0, tex.size.y - 1, pos.y);
    idx := pos.x + tex.size.x*pos.y;

    tex.pixels[idx] = val;
}

func tex_write_nearest(tex: Tex*, pos: float2, val: Color) {
    tex_poke(tex, float2_to_int2({ pos.x * (tex.size.x - 1), pos.y * (tex.size.y - 1) }), val);
}

func tex_get_lod(tex: Tex*, lod: int2): Image {
    // Pixels are laid out as a series of decreasing mips
    // Each mip is a square mip, followed by decreasing mips in the x axis, then
    // decreasing mips in the y axis

    if (lod.x < 0) {
        lod.x += tex.lod_levels;
    }

    if (lod.y < 0) {
        lod.y += tex.lod_levels;
    }

    if (lod.x < 0 || lod.x >= tex.lod_levels || lod.y < 0 || lod.y >= tex.lod_levels) {
        return {};
    }

    square_level := mini(lod.x, lod.y);
    square_size := int2 { tex.size.x >> square_level, tex.size.y >> square_level };
    square_area := square_size.x*square_size.y;
    square_lod := Image { tex.pixels + tex.size.x*tex.size.y*4 - square_area*4, square_size };

    lod_size := int2 { tex.size.x >> lod.x, tex.size.y >> lod.y };
    #assert(lod_size.x == square_lod.size.x || lod_size.y == square_lod.size.y);

    // Non-square lod sizes decrease geometrically, 1, 1/2, 1/4, 1/8, so their
    // location is the running sum, (2^n - 1)/2^n * area(lod_square).
    denom_bit := abs(lod.x - lod.y) - 1;
    numer := (1 << denom_bit) - 1;

    pixels := square_lod.pixels;
    if (lod.x > lod.y) {
        pixels += square_area + ((numer*square_area) >> denom_bit);
        #assert(pixels < square_lod.pixels + square_area*2);
    } else if (lod.y > lod.x) {
        pixels += square_area*2 + ((numer*square_area) >> denom_bit);
        #assert(pixels < square_lod.pixels + square_area*4);
    }

    #assert(pixels < tex.pixels + tex.size.x*tex.size.y*4);
    return { pixels, lod_size };
}

func tex_lookup(tex: Tex*, pos: float2): Color {
    // Todo: Make edge behaviour configurable? We only use this for looking up
    // low resolution noise right now...
    return image_sample_linear_edge(&{tex.pixels, tex.size}, pos, Edge_Wrap);
}

func tex_lookup_lod(tex: Tex*, pos: float2, lod: float2): Color {
    result := Color {};
    if (lod.x == lod.y) {
        lodi := float2_to_int2(lod);
        lodf := (float2{ lod.x - lodi.x, lod.x - lodi.x });
        a_lod := tex_get_lod(tex, lodi);
        a := image_sample_linear(&a_lod, pos);
        if (lodf.x > 1e-5) {
            b_lod := tex_get_lod(tex, add2si(lodi, 1));
            b := image_sample_linear(&b_lod, pos);
            return color_lerp(a, b, lodf.x);
        }

        return a;
    }

    lodi := float2_to_int2(lod);
    lodf := (float2{ lod.x - lodi.x, lod.y - lodi.y });
    a_lod := tex_get_lod(tex, lodi);
    b_lod := tex_get_lod(tex, add2i(lodi, { 1, 0 }));
    c_lod := tex_get_lod(tex, add2i(lodi, { 0, 1 }));
    d_lod := tex_get_lod(tex, add2i(lodi, { 1, 1 }));
    a := image_sample_linear(&a_lod, pos);
    b := image_sample_linear(&b_lod, pos);
    c := image_sample_linear(&c_lod, pos);
    d := image_sample_linear(&d_lod, pos);
    ab := color_lerp(a, b, lodf.x);
    cd := color_lerp(c, d, lodf.x);
    abcd := color_lerp(ab, cd, lodf.y);
    return abcd;
}

func draw_tex(dest: Image*, target: Rect, tex: Tex*) {
    lod := compute_lod_level(dest.size, target.size, tex.size);
    for (it := pixel_iter_begin(dest, target); pixel_iter_next(&it)) {
        rgba := tex_lookup_lod(tex, it.pos, lod);
        *it.pixel = color_blend(*it.pixel, rgba);
    }
}

func draw_tex_multiply(dest: Image*, target: Rect, tex: Tex*, multiply_color: Color) {
    lod := compute_lod_level(dest.size, target.size, tex.size);
    for (it := pixel_iter_begin(dest, target); pixel_iter_next(&it)) {
        rgba := tex_lookup_lod(tex, it.pos, lod);
        if (rgba.a) {
            rgba = color_mul1_rgb(rgba, 1. / rgba.a);
            rgba = color_mul(rgba, multiply_color);
            rgba = color_premultiply(rgba);
        }
        *it.pixel = color_blend(*it.pixel, rgba);
    }
}

func draw_outline(buffer: Color*, size: int2, color: Color) {
    for (i := 0; i < size.x; i++) {
        buffer[i] = color;
        buffer[i + (size.x - 1) * size.y] = color;
    }

    for (i := 0; i < size.y; i++) {
        buffer[i * size.x] = color;
        buffer[i * size.x + (size.x - 1)] = color;
    }
}

func all_rect(img: Image*): Rect {
    ar := float(img.size.x) / float(img.size.y);
    return {
        pos = { 0.5 * ar, 0.5 },
        size = { ar, 1 },
        rot = { 1, 0 }
    };
}

func rotation(theta: float): float2 {
    return { cos(theta), sin(theta) };
}

func rotate(v: float2, cos_sin_theta: float2): float2 {
    if (cos_sin_theta.x || cos_sin_theta.y) {
        return float2 {
            v.x * cos_sin_theta.x - v.y * cos_sin_theta.y,
            v.x * cos_sin_theta.y + v.y * cos_sin_theta.x
        };
    }

    return v;
}

func rotate_theta(v: float2, theta: float): float2 {
    return rotate(v, { cos(theta), sin(theta) });
}

func inside_normal_rect(pos: float2, aspect_ratio: float): bool {
    return pos.x >= 0 && pos.x < aspect_ratio
        && pos.y >= 0 && pos.y < 1;
}

func rect_relative(rect: Rect, abs_pos: float2): float2 {
    shift_pos := sub2(abs_pos, rect.pos);
    rot_pos := rotate(shift_pos, rect.rot);
    scaled_pos := div2s(rot_pos, rect.size.y);
    result := add2(scaled_pos, { 0.5 * rect.size.x / rect.size.y, 0.5 });
    return result;
}

func rect_absolute(rect: Rect, rel_pos: float2): float2 {
    centered_pos := sub2(rel_pos, { 0.5 * rect.size.x / rect.size.y, 0.5 });
    scaled_pos := mul2s(centered_pos, rect.size.y);
    rot_pos := rotate(scaled_pos, { rect.rot.x, -rect.rot.y });
    shift_pos := add2(rot_pos, rect.pos);
    return shift_pos;
}

func rect_to_rect(dest: Rect, src: Rect, src_pos: float2): float2 {
    s := rect_absolute(src, src_pos);
    r := rect_relative(dest, s);
    return r;
}

func rect_to_image(dest: Image*, src: Rect, src_pos: float2): float2 {
    ar := float(dest.size.x) / float(dest.size.y);
    return rect_to_rect({ pos = { ar * .5, .5 }, size = { ar, 1. } }, src, src_pos);
}

func image_to_rect(dest: Rect, src: Image*, src_pos: float2): float2 {
    ar := float(src.size.x) / float(src.size.y);
    return rect_to_rect(dest, { pos = { ar * .5, .5 }, size = { ar, 1. } }, src_pos);
}

func gray(c: float): Color {
    return { c, c, c, 1 };
}

func color_lerp(a: Color, b: Color, t: float): Color {
    return { xmm = lerp4s(a.xmm, b.xmm, t) };
}

func color_pow(a: Color, p: float): Color {
    return Color {
        pow(a.r, p),
        pow(a.g, p),
        pow(a.b, p),
        pow(a.a, p)
    };
}

func color_add(a: Color, b: Color): Color {
    return { xmm = add4(a.xmm, b.xmm) };
}

func color_sub(a: Color, b: Color): Color {
    return { xmm = sub4(a.xmm, b.xmm) };
}

func color_mul(a: Color, b: Color): Color {
    return { xmm = mul4(a.xmm, b.xmm) };
}

func color_div(a: Color, b: Color): Color {
    return { xmm = div4(a.xmm, b.xmm) };
}

func color_exp(a: Color): Color {
    return Color {
        exp(a.r),
        exp(a.g),
        exp(a.b),
        exp(a.a)
    };
}

func color_add1(a: Color, b: float): Color {
    return { xmm = add4(a.xmm, set4s(b)) };
}

func color_mul1(a: Color, b: float): Color {
    return { xmm = mul4(a.xmm, set4s(b)) };
}

func color_mul1_rgb(a: Color, b: float): Color {
    return { xmm = blend4(mul4(a.xmm, set4s(b)), a.xmm, 0b1000) };
}

func color_blend(dest: Color, src: Color): Color {
    // src + (dest * (1 - src_alpha))
    return { xmm = fma4(dest.xmm, set4s(1 - src.a), src.xmm) };
}

func color_nan(c: Color): bool {
    return isnan(c.r) || isnan(c.b) || isnan(c.g) || isnan(c.a);
}

func color_premultiply(c: Color): Color {
    return color_mul1_rgb(c, c.a);
}

func srgb(val: float): float {
    #assert(!isnan(val));
    val = clamp01(val);

    if (val <= 0.0031308) {
        return val * 12.92;
    }

    return 1.055 * pow(val, 1./2.4) - 0.055;
}

func color_to_rgb8(color: Color): RGB8 {
    result := RGB8 {
        r = uint8(clamp(0, 255, 0.5 + srgb(color.r) * 255.)),
        g = uint8(clamp(0, 255, 0.5 + srgb(color.g) * 255.)),
        b = uint8(clamp(0, 255, 0.5 + srgb(color.b) * 255.)),
    };
    return result;
}

func time_now(): double {
    ticks := SDL_GetPerformanceCounter() - app.time.sdl_start_ticks;
    return double(ticks) / double(app.time.ticks_per_sec);
}

var perlin_gradients: float2* = 0;
const PerlinGradientCountRoot = 16;
const PerlinGradientCount = PerlinGradientCountRoot*PerlinGradientCountRoot;
#static_assert((PerlinGradientCount & (PerlinGradientCount - 1)) == 0)
func perlin_gradient(p: int2): float2 {
    result := float2 {};

    if (perlin_gradients == 0) {
        for (i := 0; i < PerlinGradientCount; i++) {
            v := random_unit_vector2();
            buf_push((:void**)&perlin_gradients, &v, sizeof(v));
        }
    }

    result = perlin_gradients[(int(p.y)*PerlinGradientCountRoot + int(p.x)) & (PerlinGradientCount -1)];
    return result;
}

func perlin(p: float2, grid_size: float): float {
    p.x = mod(p.x * grid_size, grid_size);
    p.y = mod(p.y * grid_size, grid_size);

    a := float2_to_int2(p);
    b := float2_to_int2(mod2s(add2(p, {1, 0}), grid_size));
    c := float2_to_int2(mod2s(add2(p, {0, 1}), grid_size));
    d := float2_to_int2(mod2s(add2(p, {1, 1}), grid_size));

    A := perlin_gradient(a);
    B := perlin_gradient(b);
    C := perlin_gradient(c);
    D := perlin_gradient(d);

    pp: float2 = { p.x - int(p.x), p.y - int(p.y) };

    u00 := dot2(A, sub2(pp, {0,0}));
    u10 := dot2(B, sub2(pp, {1,0}));
    u01 := dot2(C, sub2(pp, {0,1}));
    u11 := dot2(D, sub2(pp, {1,1}));

    x := pp.x*pp.x*(3. - 2.*pp.x);
    y := pp.y*pp.y*(3. - 2.*pp.y);

    ab := lerp(u00, u10, x);
    cd := lerp(u01, u11, x);
    abcd := lerp(ab, cd, y);

    return abcd;
}

func perlin_octaves(p: float2, grid_size: float): float {
   return (1 / (.5+.25+.125+.0625)) *
      perlin(p, grid_size) * 0.5
    + perlin(mul2s(p, 1.5), grid_size) * 0.25
    + perlin(mul2s(p, 3.), grid_size) * 0.125
    + perlin(mul2s(p, 4.2), grid_size) * 0.0625;
}

const WorleyMaxPointsPerSquare = 6;

struct WorleySquare {
    count: int;
    points: float2[WorleyMaxPointsPerSquare];
}

var worley_squares: WorleySquare* = 0;
const WorleySquareCountRoot = 16;
const WorleySquareCount = WorleySquareCountRoot*WorleySquareCountRoot;
#static_assert(WorleySquareCount & (WorleySquareCount - 1) == 0)
func worley_square(p: float2): WorleySquare* {
    result: WorleySquare* = 0;

    if (worley_squares == 0) {
        alpha := exp(-2.01);

        for (i := 0; i < WorleySquareCount; i++) {
            w := WorleySquare {};
            w.count = clampi(1, WorleyMaxPointsPerSquare, random_poisson(alpha));
            for (j := 0; j < w.count; j++) {
                w.points[j] = { random01(), random01() };
            }
            buf_push((:void**)&worley_squares, &w, sizeof(w));
        }
    }

    result = worley_squares + ((int(p.y)*WorleySquareCountRoot + int(p.x)) & (WorleySquareCount -1));
    return result;
}

func worley(p01: float2, grid_size: float): float2 {
    p := mul2s(p01, grid_size);
    pi := floor2(p);
    pf := sub2(p, pi);

    f1 := 2*Sqrt2;
    f2 := f1;

    hit := false;

    // yes, this is faster than a loop

    {
        w := worley_square(pi);

        for (m := 0; m < w.count; m++) {
            d := distance_squared2(pf, w.points[m]);
            if (d < f1) {
                f2 = f1;
                f1 = d;
            } else if (d < f2) {
                f2 = d;
            }
        }

        // Early out. This is 5%~ of cases
        min_dist := square(min(min(pf.x, 1 - pf.x), min(pf.y, 1 - pf.y)));
        if (f2 < min_dist) {
            return { sqrt(f1), sqrt(f2) };
        }
    }

    {
        i := -1.;
        j := 0.;
        face_dist := square(pf.x);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 1.;
        j := 0.;
        face_dist := square(1. - pf.x);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 0.;
        j := -1.;
        face_dist := square(pf.y);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 0.;
        j := 1.;
        face_dist := square(1. - pf.y);

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := -1.;
        j := -1.;
        face_dist := magnitude_squared2({ pf.x, pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }


    {
        i := 1.;
        j := -1.;
        face_dist := magnitude_squared2({ 1. - pf.x, pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := -1.;
        j := 1.;
        face_dist := magnitude_squared2({ pf.x, 1. - pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    {
        i := 1.;
        j := 1.;
        face_dist := magnitude_squared2({ 1. - pf.x, 1. - pf.y });

        if (face_dist < f2) {
            p_ij := add2(pi, { i, j });
            w := worley_square(p_ij);

            for (m := 0; m < w.count; m++) {
                d := distance_squared2(p, add2(p_ij, w.points[m]));
                if (d < f1) {
                    f2 = f1;
                    f1 = d;
                } else if (d < f2) {
                    f2 = d;
                }
            }
        }
    }

    #assert(f1 <= f2);
    #assert(f2 >= 0);
    return { sqrt(f1), sqrt(f2) };
}

func worley_octaves(p: float2, grid_size: float): float2 {
    s := (1 / (.5+.25+.125+.0625));
    a := mul2s(worley(p, grid_size), 0.5);
    b := mul2s(worley(mul2s(p, 1.5), grid_size), 0.25);
    c := mul2s(worley(mul2s(p, 3.), grid_size), 0.125);
    d := mul2s(worley(mul2s(p, 4.2), grid_size), 0.0625);

    return mul2s(add2(a, add2(b, add2(c, d))), s);
}

func luminance(c: Color): float {
    // https://en.wikipedia.org/w/index.php?title=Relative_luminance&oldid=817127289
    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;
}

func uncharted2duiker(x: float): float {
               // Original values
    a := 0.1;  // 0.15
    b := 0.15; // 0.5
    c := 0.1;
    d := 0.2;
    e := 0.02;
    f := 0.3;
    return ((x*(a*x+c*b)+d*e)/(x*(a*x+b)+d*f))-e/f;
}

func calculate_luminance(img: Image*): float2 {
    b := image_copy(img);
    Lmax := 0.;
    for (it := pixel_iter_begin(&b, {}); pixel_iter_next(&it)) {
        lum := luminance(*it.pixel);
        if (lum > srgb(1./255)) {
            it.pixel.a = log(1e-5 + luminance(*it.pixel));
        }
        Lmax = max(Lmax, lum);
    }
    blur_asym(&b, mul2s(int2_to_float2(ImageSize), 0.5));
    Lw := exp(image_sample_linear(&b, {.5, .5}).a);
    return { Lw, Lmax };
}

func post_process(img: Image*, small_blur: Image*, big_blur: Image*, Lw: float, Lmax: float, color_adjustment: Color) {
    mix := color_adjustment.a;

    adjust := color_adjustment;
    adjust.a = 1. / luminance(color_adjustment);
    adjust = color_premultiply(adjust);

    a := remap(0, 10000, 6, 1, clamp(0, 10000, Lmax));
    for (it := pixel_iter_begin(img, {}); pixel_iter_next(&it)) {
        // Layer blurs
        bp := image_fetch(small_blur, it.pixel_pos);
        mbp := color_mul(*it.pixel, bp);
        xbp := color_lerp(bp, mbp, 0.1);

        bp2 := image_fetch(big_blur, it.pixel_pos);
        mbp2 := color_mul(*it.pixel, bp2);
        xbp2 := color_lerp(bp2, mbp2, .9);
        c := color_add(*it.pixel, color_add(xbp, xbp2));

        // Tonemap
        it.pixel.r = lerp(c.r, a * (adjust.r * uncharted2duiker(c.r) / uncharted2duiker(Lw)), mix);
        it.pixel.g = lerp(c.g, a * (adjust.g * uncharted2duiker(c.g) / uncharted2duiker(Lw)), mix);
        it.pixel.b = lerp(c.b, a * (adjust.b * uncharted2duiker(c.b) / uncharted2duiker(Lw)), mix);
    }
}

struct Threads {
    threads: SDL_Thread*;
    thread_count: int;
    work_available_sem: SDL_sem*;
    work_completed_sem: SDL_sem*;

    work: WorkItem*;

    // Only the main thread touches these.
    started: bool;
    work_count: int;

    // Worker threads touch this.
    work_token: volatile_long;
    work_index: volatile_long;
    work_completed: volatile_long;
}

var threads: Threads;
const WorkItems = 8;

enum WorkType {
    WorkType_None = 0,
    WorkType_DrawStarfield,
    WorkType_BlurTo,
    WorkType_CalculateLuminance,
    WorkType_PostProcess,
}
struct draw_starfieldArgs {
    img: Image*;
    wr: WritableRegion;
    starfield: Starfield*;
}
struct blur_toArgs {
    dest: Image*;
    src: Image*;
    radius: float;
}
struct calculate_luminanceArgs {
    img: Image*;
    result: float2*;
}
struct post_processArgs {
    img: Image*;
    wr: WritableRegion;
    small_blur: Image*;
    big_blur: Image*;
    Lw: float;
    Lmax: float;
    color_adjustment: Color;
}
union WorkArgs {
    draw_starfield: draw_starfieldArgs;
    blur_to: blur_toArgs;
    calculate_luminance: calculate_luminanceArgs;
    post_process: post_processArgs;
}
struct WorkItem {
    type: WorkType;
    args: WorkArgs;
}

func get_work(completed: int): WorkItem* {
    work: WorkItem* = 0;

    if (completed == threads.work_index) {
        SDL_SemPost(threads.work_completed_sem);
        SDL_SemWait(threads.work_available_sem);
    }

    while (true) {
        token := interlocked_increment(&threads.work_token) - 1;

        if (token < threads.work_index) {
            work = threads.work + (token & (WorkItems - 1));
            #assert(work.type != WorkType_None);
            SDL_SemPost(threads.work_available_sem);
            break;
        }

        SDL_SemWait(threads.work_available_sem);
    }

    return work;
}

func threads_thread(data: void*): int {
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);

    completed := threads.work_completed;
    SDL_SemWait(threads.work_available_sem);

    while(true) {
        work := get_work(completed);

        t0 := time_now();
        switch (work.type) {
            case WorkType_DrawStarfield: {
                img := *work.args.draw_starfield.img;
                img.wr = work.args.draw_starfield.wr;
                draw_starfield(&img, work.args.draw_starfield.starfield);
            }
            case WorkType_BlurTo: {
                blur_to(work.args.blur_to.dest, work.args.blur_to.src, work.args.blur_to.radius);
            }
            case WorkType_CalculateLuminance: {
                *work.args.calculate_luminance.result = calculate_luminance(work.args.calculate_luminance.img);
            }
            case WorkType_PostProcess: {
                img := *work.args.post_process.img;
                img.wr = work.args.post_process.wr;
                post_process(&img, work.args.post_process.small_blur, work.args.post_process.big_blur, work.args.post_process.Lw, work.args.post_process.Lmax, work.args.post_process.color_adjustment);
            }
            default: #assert(!"Bad work type");
        }

        t1 := time_now();
        printf("type %d: %f elapsed\n", work.type, (t1-t0)*1000);
        work.type = WorkType_None;

        completed = interlocked_increment(&threads.work_completed);
    }

    return 0;
}

func threads_init(threads: Threads*) {
    threads.work_available_sem = SDL_CreateSemaphore(0);
    threads.work_completed_sem = SDL_CreateSemaphore(0);
    threads.thread_count = SDL_GetCPUCount();

    threads.work_count = WorkItems;
    threads.work = xcalloc(sizeof(WorkItem), threads.work_count);

    for (i := 0; i < threads.thread_count; i++) {
        thread := SDL_CreateThread(threads_thread, 0, 0);
        buf_push((:void**)&threads.threads, &thread, sizeof(thread));
    }
}

func threads_fork(threads: Threads*) {
    if (threads.started == false) {
        threads.started = true;
        SDL_SemPost(threads.work_available_sem);
    }
}

func threads_join(threads: Threads*) {
    threads_fork(threads);
    SDL_SemWait(threads.work_completed_sem);
    #assert(threads.work_completed == threads.work_index);

    threads.started = false;
    threads.work_completed = 0;
    threads.work_index = 0;
    threads.work_token = 0;
}

func threads_draw_starfield(threads: Threads*, img: Image*, wr: WritableRegion, starfield: Starfield*) {
    #assert(threads.work_index < threads.work_count);
    #assert(threads.started == false);
    threads.work[threads.work_index].type = WorkType_DrawStarfield;
    threads.work[threads.work_index++].args = {
        draw_starfield = { img, wr, starfield }
    };
}

func threads_blur_to(threads: Threads*, dest: Image*, src: Image*, radius: float) {
    #assert(threads.work_index < threads.work_count);
    #assert(threads.started == false);
    threads.work[threads.work_index].type = WorkType_BlurTo;
    threads.work[threads.work_index++].args = {
        blur_to = { dest, src, radius }
    };
}

func threads_calculate_luminance(threads: Threads*, img: Image*, result_out: float2*) {
    #assert(threads.work_index < threads.work_count);
    #assert(threads.started == false);
    #assert(result_out);
    threads.work[threads.work_index].type = WorkType_CalculateLuminance;
    threads.work[threads.work_index++].args = {
        calculate_luminance = { img, result_out }
    };
}

func threads_post_process(threads: Threads*, img: Image*, wr: WritableRegion, small_blur: Image*, big_blur: Image*, Lw: float, Lmax: float, color_adjustment: Color) {
    #assert(threads.work_index < threads.work_count);
    #assert(threads.started == false);
    threads.work[threads.work_index].type = WorkType_PostProcess;
    threads.work[threads.work_index++].args = {
        post_process = { img, wr, small_blur, big_blur, Lw, Lmax, color_adjustment }
    };
}

// Unique for each image.
var diffraction_rotation: float2 = {};

func main(argc: int, argv: char**): int {
    if (true) {
        test_pixel_iterator({32,32});
        test_pixel_iterator({64,32});
        test_pixel_iterator({32,64});
        test_pixel_iterator({8,1024});
    }
    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
    _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);

    app.window.size = ImageSize;
    if (!app_init()) {
        print_and_clear_error();
        return 1;
    }

    surface := SDL_GetWindowSurface(app.window.sdl);
    renderer := SDL_CreateSoftwareRenderer(surface);
    #assert(surface.format.format == SDL_PIXELFORMAT_RGB888);
    #assert(surface.format.BitsPerPixel == 32);
    #assert(surface.w == ImageSize.x);
    #assert(surface.h == ImageSize.y);

    starfield_text :="""
✺   　　 　　 ·   ⊹
 *  ⋆ 　　　  ✧  *
  　　　　　　　.  　
 +  *　  　* 　　. 　 ⋆
    　　  +   ✫
""";

    text_len := strlen(starfield_text);

    text_hash := hash(starfield_text, text_len);

    random_state = (:uint32)text_hash;
    threads_init(&threads);

    diffraction_rotation = random_unit_vector2();

    starfield := Starfield {};
    starfield;

    min_t := 100000.;
    max_t := 0.;
    sum_t := 0.;
    n_t := 0;
    t_reset := time_now();

    iters := 0;
    profiling := (argc > 1) ? (*argv[1] != 'b') : true;

    image := make_image(ImageSize);
    blurred := make_image(ImageSize);
    blurred2 := make_image(ImageSize);
    blurred;
    blurred2;
    while (app_update() && iters < 15) {
        if (app.error) {
            print_and_clear_error();
        }

        if (profiling) {
            iters++;
        }

        if (profiling || !n_t || app.mouse.left_button.pressed) {
            image_clear(&image);

            if (worley_squares) {
                buf_free(worley_squares);
                worley_squares = 0;
            }
            if (perlin_gradients) {
                buf_free(perlin_gradients);
                perlin_gradients = 0;
            }
            free_starfield(&starfield);

            t0 := time_now();
            t0f := float(t0);

            noise := make_image(ImageSize);
            noise_level := (1 - square(random01())) / randomn(2048, 5192);
            for (it := pixel_iter_begin(&noise, {}); pixel_iter_next(&it)) {
                c := Color {
                    square(random_normal()) * (noise_level),
                    square(random_normal()) * (noise_level),
                    square(random_normal()) * (noise_level),
                    1
                };
                *it.pixel = c;
            }
            blur(&noise, 0.1);
            image_copy_to(&image, &noise);

            starfield = create_starfield(starfield_text);
            worley_square({});
            perlin_gradient({});

            bands := threads.thread_count;
            y_wr_step := image.size.y / bands;
            wr := WritableRegion { 0, 0, image.size.x, y_wr_step };

            while (wr.y0 < image.size.y) {
                threads_draw_starfield(&threads, &image, wr, &starfield);
                wr.y0 += y_wr_step;
                wr.y1 += y_wr_step;
            }

            threads_join(&threads);

            lum := float2 {};
            threads_blur_to(&threads, &blurred, &image, randomr(0, 1)); // ~1.33
            threads_blur_to(&threads, &blurred2, &image, randomr(0.5,2)); // ~2
            threads_calculate_luminance(&threads, &image, &lum);

            threads_fork(&threads);

            diffract(&image, {
                alpha = 0.01,
                radius = 2,
                transform = diffraction_rotation,
                type = randomn(1, DiffractionTypeCount)
            });

            threads_join(&threads);

            wr = WritableRegion { 0, 0, image.size.x, y_wr_step };
            color_adjustment := Color {
                clamp_low(.1, 2.3 + random_normal()*0.5),
                clamp_low(.1, 2 + random_normal()*0.5),
                clamp_low(.1, 1.7 + random_normal()*0.6),
                1 - square(random01())
            };

            while (wr.y0 < image.size.y) {
                threads_post_process(&threads, &image, wr, &blurred, &blurred2, lum.x, lum.y, color_adjustment);
                wr.y0 += y_wr_step;
                wr.y1 += y_wr_step;
            }

            threads_join(&threads);

            image_to_rgb8((:RGB8*)surface.pixels, { surface.w, surface.h }, &image);

            t1 := time_now();

            free_image(&noise);

            t := float((t1 - t0)*1000);
            min_t = min(t, min_t);
            max_t = max(t, max_t);
            sum_t += t;
            n_t++;

            if (profiling || app.mouse.left_button.pressed) {
                // Regen galaxy every time. This is a good candidate for
                // multithreading but is the only big bit of work not started
                // directly by this top level
                // init_star_type_really(star_types + 12, true);

                printf("cur %.2fms min %.2fms max %.2fms avg %.2fms\n", t, min_t, max_t, sum_t/n_t);

                t_reset = t0;
            }
        }


        SDL_UpdateWindowSurface(app.window.sdl);

        fflush(stdout);

        if (!profiling) {
            SDL_WaitEvent(0);
        }
    }

    return 0;
}