struct WritableRegion {
    // Top left inclusive
    x0: int;
    y0: int;
    // Bottom right exclusive
    x1: int;
    y1: int;
}

struct Image {
    pixels: Color*;
    size: int2;
    wr: WritableRegion;
}

func make_image(size: int2): Image {
    return Image {
        pixels = xcalloc(size.x*size.y, sizeof(Color)),
        size = size,
        wr = { 0, 0, size.x, size.y }
    };
}

func make_image_like(img: Image*, downsample: int): Image {
    size := div2si(img.size, downsample);
    return Image {
        pixels = xcalloc(size.x*size.y, sizeof(Color)),
        size = size,
        wr = { img.wr.x0 / downsample, img.wr.y0 / downsample, img.wr.x1 / downsample, img.wr.y1 / downsample }
    };
}

func free_image(img: Image*) {
    #assert(img.pixels);
    free(img.pixels);
    img.pixels = 0;
    img.size = { 0, 0 };
}

func image_clear(img: Image*) {
    memset(img.pixels, 0, img.size.x*img.size.y*sizeof(Color));
}

func image_copy(img: Image*): Image {
    #assert(img.pixels);
    result := make_image(img.size);
    memcpy(result.pixels, img.pixels, img.size.x*img.size.y*sizeof(Color));
    return result;
}

func image_copy_to(dest: Image*, src: Image*) {
    if ((src.size.x == dest.size.x) && (src.size.y == dest.size.y)) {
        memcpy(dest.pixels, src.pixels, src.size.x*src.size.y*sizeof(Color));
    } else {
        for (it := pixel_iter_begin(dest, {}); pixel_iter_next(&it)) {
            *it.pixel = image_sample_nearest(src, it.pos);
        }
    }
}

func image_to_rgb8(dest: RGB8*, size: int2, src: Image*) {
    #assert(src.size.x == size.x);
    #assert(src.size.y == size.y);
    src_end := src.pixels + src.size.x*src.size.y;
    for (src_it := src.pixels; src_it != src_end; src_it++) {
        *dest = color_to_rgb8(*src_it);
        dest++;
    }
}

func explicit_writable_region(img: Image*): WritableRegion {
    return {
        x0 = img.wr.x0,
        y0 = img.wr.y0,
        x1 = img.wr.x1 ? clampi(0, img.size.x, img.wr.x1) : img.size.x,
        y1 = img.wr.y1 ? clampi(0, img.size.y, img.wr.y1) : img.size.y,
    };
}

func writable_at(wr: WritableRegion, pos: int2): bool {
    return (pos.x >= wr.x0 && pos.x < wr.x1) &&
           (pos.y >= wr.y0 && pos.y < wr.y1);
}

struct PixelIter {
    image: Image;
    aspect_ratio: float;
    start: int2;
    end: int2;
    rect: Rect;
    pixel_pos: int2;
    line_start: float2;
    dx: float2;
    dy: float2;

    pos: float2;
    img_pos: float2;
    pixel: Color*;
}

func pixel_iter_begin_tex(tex: Tex*, rect: Rect): PixelIter {
    return pixel_iter_begin(&{tex.pixels, tex.size}, rect);
}

func pixel_iter_begin(image: Image*, rect: Rect): PixelIter {
    iter: PixelIter = {};

    if (is_zero(&rect, sizeof(rect))) {
        rect = all_rect(image);
    }

    aspect_ratio := rect.size.x / rect.size.y;

    x_min := 0.;
    x_max := aspect_ratio;
    y_min := 0.;
    y_max := 1.;

    a := rect_to_image(image, rect, { x_min,  y_min });
    b := rect_to_image(image, rect, { x_max,  y_min });
    c := rect_to_image(image, rect, { x_min,  y_max });
    d := rect_to_image(image, rect, { x_max,  y_max });

    x_min = smin4(a.x, b.x, c.x, d.x);
    x_max = smax4(a.x, b.x, c.x, d.x);
    y_min = smin4(a.y, b.y, c.y, d.y);
    y_max = smax4(a.y, b.y, c.y, d.y);

    origin := image_to_rect(rect, image, { 0, 0 });
    iter.dx = sub2(image_to_rect(rect, image, { 1. / image.size.y, 0 }), origin);
    iter.dy = sub2(image_to_rect(rect, image, { 0, 1. / image.size.y }), origin);

    iter.image = *image;
    iter.image.wr = explicit_writable_region(image);

    iter.start.x = clampi(iter.image.wr.x0, iter.image.wr.x1 - 1, int(ceil(x_min * image.size.y - 0.5)));
    iter.start.y = clampi(iter.image.wr.y0, iter.image.wr.y1 - 1, int(ceil(y_min * image.size.y - 0.5)));
    iter.end.x   = clampi(iter.image.wr.x0, iter.image.wr.x1 - 1, int(x_max * image.size.y - 0.5)) + 1;
    iter.end.y   = clampi(iter.image.wr.y0, iter.image.wr.y1 - 1, int(y_max * image.size.y - 0.5)) + 1;

    iter.pixel_pos = { iter.start.x - 1, iter.start.y };
    iter.img_pos = { (0.5 + iter.pixel_pos.x) / image.size.y, (0.5 + iter.pixel_pos.y) / image.size.y };
    iter.pos = image_to_rect(rect, image, iter.img_pos);
    iter.line_start = iter.pos;
    iter.aspect_ratio = aspect_ratio;
    iter.rect = rect;

    return iter;
}

func pixel_iter_next(it: PixelIter*): bool {
    it.pixel_pos.x++;

    for (; it.pixel_pos.y < it.end.y; it.pixel_pos.y++) {
        for (; it.pixel_pos.x < it.end.x; it.pixel_pos.x++) {
            // Todo: used fixed point instead?
            it.pos = add2(it.pos, it.dx);

            if (inside_normal_rect(it.pos, it.aspect_ratio) && writable_at(it.image.wr, it.pixel_pos)) {
                it.pixel = it.image.pixels + (it.pixel_pos.x + it.pixel_pos.y*it.image.size.x);
                it.img_pos =  { (0.5 + it.pixel_pos.x) / it.image.size.y, (0.5 + it.pixel_pos.y) / it.image.size.y };
                return true;
            }
        }

        it.line_start = add2(it.line_start, it.dy);
        it.pos = it.line_start;
        it.pixel_pos.x = it.start.x;
    }

    return false;
}

func test_pixel_iterator(dim: int2) {
    img := make_image(dim);

    for (i := 0; i < dim.x; i++) {
        for (j := 0; j < dim.y; j++) {
            r := Color {
                random01(),
                random01(),
                random01(),
                random01()
            };

            img.pixels[i + j*dim.x] = r;
        }
    }

    {
        i := 0;
        j := 0;
        for (it := pixel_iter_begin(&img, all_rect(&img)); pixel_iter_next(&it)) {
            p := img.pixels[i + j*dim.x];
            c := image_sample_linear(&img, it.pos);
            d := image_sample_nearest(&img, it.pos);
            #assert(fabs(p.r - c.r) < 1e-5);
            #assert(fabs(p.g - c.g) < 1e-5);
            #assert(fabs(p.b - c.b) < 1e-5);
            #assert(fabs(p.a - c.a) < 1e-5);
            #assert(p.r == d.r);
            #assert(p.g == d.g);
            #assert(p.b == d.b);
            #assert(p.a == d.a);

            i++;
            if (i == dim.x) {
                i = 0;
                j++;
            }
        }
        #assert(i + j*dim.x == dim.x*dim.y);
    }

    {
        half_dim := div2si(dim, 2);

        i := 0;
        j := 0;
        rect := all_rect(&img);
        rect.size.x /= 2;
        rect.size.y /= 2;
        pp := img.pixels + dim.x/4 + (dim.y/4)*dim.x;
        for (it := pixel_iter_begin(&img, rect); pixel_iter_next(&it)) {
            p := *pp++;
            c := image_sample_linear(&img, it.img_pos);
            d := image_sample_nearest(&img, it.img_pos);
            #assert(fabs(p.r - c.r) < 1e-5);
            #assert(fabs(p.g - c.g) < 1e-5);
            #assert(fabs(p.b - c.b) < 1e-5);
            #assert(fabs(p.a - c.a) < 1e-5);
            #assert(p.r == d.r);
            #assert(p.g == d.g);
            #assert(p.b == d.b);
            #assert(p.a == d.a);

            i++;
            if (i == half_dim.x) {
                i = 0;
                j++;
                pp = pp - half_dim.x + dim.x;
            }
        }
        #assert(i + j*half_dim.x == half_dim.x*half_dim.y);
    }
    free_image(&img);
}

func assert_correct_signs(a: float, b: float, c: float, d: float, ab: float, cd: float, abcd: float) {
    if (a > 0 && b > 0) {
        #assert(ab >= 0);
        if (c > 0 && d > 0) {
            #assert(cd >= 0);
            #assert(abcd >= 0);
        }
    }
    if (c > 0 && d > 0) {
        #assert(cd >= 0);
    }
}

enum EdgeBehavior {
    Edge_Black,
    Edge_Clamp,
    Edge_Wrap
}

func image_sample_linear(img: Image*, pos: float2): Color {
    return image_sample_linear_edge(img, pos, Edge_Black);
}

func image_sample_linear_edge(img: Image*, pos: float2, edge_behavior: EdgeBehavior): Color {
    if (img.pixels == 0) {
        return {};
    }

    #assert(img.size.x);
    #assert(img.size.y);

    scaled := float2 {
        pos.x * img.size.y - 0.5,
        pos.y * img.size.y - 0.5,
    };

    vi := float2_to_int2(scaled);
    vf := sub2(scaled, int2_to_float2(vi));

    a := vi;
    b := add2i(a, {1, 0});
    c := add2i(a, {0, 1});
    d := add2i(a, {1, 1});

    A: Color;
    B: Color;
    C: Color;
    D: Color;

    if (edge_behavior == Edge_Black) {
        a_idx: uint = a.x + a.y*img.size.x;
        b_idx: uint = b.x + b.y*img.size.x;
        c_idx: uint = c.x + c.y*img.size.x;
        d_idx: uint = d.x + d.y*img.size.x;
        end: uint = img.size.x*img.size.y;
        A = (a_idx < end) ? img.pixels[a_idx] : {};
        B = (b_idx < end) ? img.pixels[b_idx] : {};
        C = (c_idx < end) ? img.pixels[c_idx] : {};
        D = (d_idx < end) ? img.pixels[d_idx] : {};
    } else {
        if (edge_behavior == Edge_Clamp) {
            a.x = clampi(0, img.size.x - 1, a.x);
            b.x = clampi(0, img.size.x - 1, b.x);
            c.x = clampi(0, img.size.x - 1, c.x);
            d.x = clampi(0, img.size.x - 1, d.x);
            a.y = clampi(0, img.size.y - 1, a.y);
            b.y = clampi(0, img.size.y - 1, b.y);
            c.y = clampi(0, img.size.y - 1, c.y);
            d.y = clampi(0, img.size.y - 1, d.y);
        } else if (edge_behavior == Edge_Wrap) {
            a.x = (a.x == img.size.x) ? a.x - img.size.x : a.x;
            b.x = (b.x == img.size.x) ? b.x - img.size.x : b.x;
            c.x = (c.x == img.size.x) ? c.x - img.size.x : c.x;
            d.x = (d.x == img.size.x) ? d.x - img.size.x : d.x;
            a.y = (a.y == img.size.y) ? a.y - img.size.y : a.y;
            b.y = (b.y == img.size.y) ? b.y - img.size.y : b.y;
            c.y = (c.y == img.size.y) ? c.y - img.size.y : c.y;
            d.y = (d.y == img.size.y) ? d.y - img.size.y : d.y;
        }

        A = img.pixels[a.x + a.y*img.size.x];
        B = img.pixels[b.x + b.y*img.size.x];
        C = img.pixels[c.x + c.y*img.size.x];
        D = img.pixels[d.x + d.y*img.size.x];
    }

    AB := color_lerp(A, B, vf.x);
    CD := color_lerp(C, D, vf.x);
    ABCD := color_lerp(AB, CD, vf.y);

    return ABCD;
}

func image_sample_nearest(img: Image*, pos: float2): Color {
    if (img.pixels == 0) {
        return {};
    }

    #assert(img.size.x);
    #assert(img.size.y);

    // Round to pixel center. x + .5 - .5 = x
    p := int2 { int(pos.x * img.size.y), int(pos.y * img.size.y) };
    return image_fetch(img, p);
}

func image_fetch(img: Image*, pos: int2): Color {
    if (img.pixels == 0 || pos.x < 0 || pos.x >= img.size.x || pos.y < 0 || pos.y >= img.size.y) {
        #assert(0);
        return {};
    }

    #assert(pos.x + pos.y*img.size.x < img.size.x*img.size.y);
    return img.pixels[pos.x + pos.y*img.size.x];
}