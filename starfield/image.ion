const PixelEps = 1e-7;

struct Image {
    pixels: Color*;
    size: int2;
}

func make_image(size: int2): Image {
    return Image {
        pixels = xcalloc(size.x*size.y, sizeof(Color)),
        size = size
    };
}

func free_image(img: Image*) {
    #assert(img.pixels);
    free(img.pixels);
    img.pixels = 0;
    img.size = { 0, 0 };
}

func image_clear(img: Image*) {
    memset(img.pixels, 0, img.size.x*img.size.y*sizeof(Color));
}

func image_copy(img: Image*): Image {
    #assert(img.pixels);
    result := make_image(img.size);
    memcpy(result.pixels, img.pixels, img.size.x*img.size.y*sizeof(Color));
    return result;
}

func image_copy_to(dest: Image*, src: Image*) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    memcpy(dest.pixels, src.pixels, src.size.x*src.size.y*sizeof(Color));
}

func image_to_rgb8(dest: RGB8*, size: int2, src: Image*) {
    #assert(src.size.x == size.x);
    #assert(src.size.y == size.y);
    src_end := src.pixels + src.size.x*src.size.y;
    for (src_it := src.pixels; src_it != src_end; src_it++) {
        *dest = color_to_rgb8(*src_it);
        dest++;
    }
}

struct PixelIter {
    image: Image*;
    aspect_ratio: float;
    start: int2;
    end: int2;
    rect: Rect;
    pixel_pos: int2;
    line_start: float2;
    dx: float2;
    dy: float2;

    pos: float2;
    abs_pos: float2;
    pixel: Color*;
}

func pixel_iter_begin_tex(tex: Tex*, rect: Rect): PixelIter {
    #static_assert(offsetof(Tex, pixels) == offsetof(Image, pixels));
    #static_assert(offsetof(Tex, size) == offsetof(Image, size));
    return pixel_iter_begin((:Image*)tex, rect);
}

func pixel_iter_begin(image: Image*, rect: Rect): PixelIter {
    iter: PixelIter = {};

    aspect_ratio := float(image.size.x) / float(image.size.y);

    x_min := 0.;
    x_max := 1.;
    y_min := 0.;
    y_max := 1.;
    start_pos := clamp2(0, 1,  rect_absolute(rect, aspect_ratio, {0, 0}));

    if (!is_zero(&rect, sizeof(rect))) {
        a := start_pos;
        b := clamp2(0, 1, rect_absolute(rect, aspect_ratio, {1, 0}));
        c := clamp2(0, 1, rect_absolute(rect, aspect_ratio, {0, 1}));
        d := clamp2(0, 1, rect_absolute(rect, aspect_ratio, {1, 1}));

        x_min = min4(a.x, b.x, c.x, d.x);
        x_max = max4(a.x, b.x, c.x, d.x);
        y_min = min4(a.y, b.y, c.y, d.y);
        y_max = max4(a.y, b.y, c.y, d.y);

        origin := rect_relative(rect, aspect_ratio, { 0, 0 });
        iter.dx = sub2(rect_relative(rect, aspect_ratio, { 1. / image.size.x, 0 }), origin);
        iter.dy = sub2(rect_relative(rect, aspect_ratio, { 0, 1. / image.size.y }), origin);
    } else {
        rect = all_rect();
        iter.dx = { 1. / image.size.x, 0. };
        iter.dy = { 0., 1. / image.size.y };
    }

    iter.start.x = int(ceil(x_min * image.size.x - 0.5 + PixelEps));
    iter.end.x   = int(x_max * image.size.x - 0.5 + PixelEps) + 1;
    iter.start.y = int(ceil(y_min * image.size.y - 0.5 + PixelEps));
    iter.end.y   = int(y_max * image.size.y - 0.5 + PixelEps) + 1;

    iter.pixel_pos = { iter.start.x - 1, iter.start.y };
    iter.pos = rect_relative(rect, aspect_ratio, { float(0.5 + iter.pixel_pos.x) / image.size.x, float(0.5 + iter.pixel_pos.y) / image.size.y });
    iter.abs_pos = rect_relative(rect, aspect_ratio, iter.pos);
    iter.line_start = iter.pos;
    iter.aspect_ratio = aspect_ratio;
    iter.rect = rect;
    iter.image = image;

    return iter;
}

func pixel_iter_next(it: PixelIter*): bool {
    it.pixel_pos.x++;

    for (; it.pixel_pos.y < it.end.y; it.pixel_pos.y++) {
        for (; it.pixel_pos.x < it.end.x; it.pixel_pos.x++) {
            // Todo: would be nice to know the effect of floating point
            // accumulation here.
            it.pos = add2(it.pos, it.dx);

            if (inside_normal_rect(it.pos)) {
                it.pixel = it.image.pixels + (it.pixel_pos.x + it.pixel_pos.y*it.image.size.x);
                it.abs_pos = rect_relative(it.rect, it.aspect_ratio, it.pos);
                return true;
            }
        }

        it.line_start = add2(it.line_start, it.dy);
        it.pos = it.line_start;
        it.pixel_pos.x = it.start.x;
    }

    return false;
}

func test_iterator() {
    dim := int2 { 32, 32 };
    img := make_image(dim);

    for (i := 0; i < dim.x; i++) {
        for (j := 0; j < dim.y; j++) {
            r := Color {
                random01(),
                random01(),
                random01(),
                random01()
            };

            img.pixels[i + j*dim.x] = r;
        }
    }

    i := 0;
    j := 0;
    for (it := pixel_iter_begin(&img, all_rect()); pixel_iter_next(&it)) {
        p := img.pixels[i + j*dim.x];
        c := image_sample_linear(&img, it.pos);
        d := image_sample_nearest(&img, it.pos);
        #assert(p.r - c.r < 1e-5);
        #assert(p.g - c.g < 1e-5);
        #assert(p.b - c.b < 1e-5);
        #assert(p.a - c.a < 1e-5);
        #assert(p.r == d.r);
        #assert(p.g == d.g);
        #assert(p.b == d.b);
        #assert(p.a == d.a);

        i++;
        if (i == dim.x) {
            i = 0;
            j++;
        }
    }
    #assert(i + j*dim.x == dim.x*dim.y);
}

func assert_correct_signs(a: float, b: float, c: float, d: float, ab: float, cd: float, abcd: float) {
    if (a > 0 && b > 0) {
        #assert(ab >= 0);
        if (c > 0 && d > 0) {
            #assert(cd >= 0);
            #assert(abcd >= 0);
        }
    }
    if (c > 0 && d > 0) {
        #assert(cd >= 0);
    }
}

enum EdgeBehavior {
    Edge_Clamp,
    Edge_Wrap
}

func image_sample_linear(img: Image*, pos: float2): Color {
    return image_sample_linear_edge(img, pos, Edge_Clamp);
}

func image_sample_linear_edge(img: Image*, pos: float2, edge_behavior: EdgeBehavior): Color {
    if (img.pixels == 0) {
        return {};
    }

    edge_behavior = Edge_Clamp;

    #assert(img.size.x);
    #assert(img.size.y);

    scaled := float2 {
        pos.x * img.size.x - 0.5 + PixelEps,
        pos.y * img.size.y - 0.5 + PixelEps,
    };

    if (edge_behavior == Edge_Clamp) {
        scaled.x = clamp(0, float(img.size.x), scaled.x);
        scaled.y = clamp(0, float(img.size.y), scaled.y);
    } else if (edge_behavior == Edge_Wrap) {
        scaled.x = wrap(scaled.x, float(img.size.x));
        scaled.y = wrap(scaled.y, float(img.size.y));
    } else {
        #assert(0);
    }

    vi := float2_to_int2(scaled);
    vf := sub2(scaled, int2_to_float2(vi));

    a := vi;
    b := add2i(a, {1, 0});
    c := add2i(a, {0, 1});
    d := add2i(a, {1, 1});

    #assert(a.x >= 0 && a.x < img.size.x);
    #assert(a.y >= 0 && a.y < img.size.y);

    if (edge_behavior == Edge_Clamp) {
        b.x = clampi_high(img.size.x - 1, b.x);
        c.x = clampi_high(img.size.x - 1, c.x);
        d.x = clampi_high(img.size.x - 1, d.x);
        b.y = clampi_high(img.size.y - 1, b.y);
        c.y = clampi_high(img.size.y - 1, c.y);
        d.y = clampi_high(img.size.y - 1, d.y);
    } else if (edge_behavior == Edge_Wrap) {
        b.x = (b.x == img.size.x) ? 0 : b.x;
        c.x = (c.x == img.size.x) ? 0 : c.x;
        d.x = (d.x == img.size.x) ? 0 : d.x;
        b.y = (b.y == img.size.y) ? 0 : b.y;
        c.y = (c.y == img.size.y) ? 0 : c.y;
        d.y = (d.y == img.size.y) ? 0 : d.y;
    }

    A := img.pixels[a.x + a.y*img.size.x];
    B := img.pixels[b.x + b.y*img.size.x];
    C := img.pixels[c.x + c.y*img.size.x];
    D := img.pixels[d.x + d.y*img.size.x];

    AB := color_lerp(A, B, vf.x);
    CD := color_lerp(C, D, vf.x);
    ABCD := color_lerp(AB, CD, vf.y);

    // assert_correct_signs(A.r, B.r, C.r, D.r, AB.r, CD.r, ABCD.r);
    // assert_correct_signs(A.g, B.g, C.g, D.g, AB.g, CD.g, ABCD.g);
    // assert_correct_signs(A.b, B.b, C.b, D.b, AB.b, CD.b, ABCD.b);
    // assert_correct_signs(A.a, B.a, C.a, D.a, AB.a, CD.a, ABCD.a);

    return ABCD;
}

func sample_linear(pixels: float*, size: int2, pos: float2, edge_behavior: EdgeBehavior): float {
    if (pixels == 0) {
        return {};
    }

    #assert(size.x);
    #assert(size.y);

    scaled := float2 {
        pos.x * size.x - 0.5,
        pos.y * size.y - 0.5,
    };

    if (edge_behavior == Edge_Clamp) {
        scaled.x = clamp(0, float(size.x), scaled.x);
        scaled.y = clamp(0, float(size.y), scaled.y);
    } else if (edge_behavior == Edge_Wrap) {
        scaled.x = wrap(scaled.x, float(size.x));
        scaled.y = wrap(scaled.y, float(size.y));
    } else {
        #assert(0);
    }

    vi := float2_to_int2(scaled);
    vf := sub2(scaled, int2_to_float2(vi));

    a := vi;
    b := add2i(a, {1, 0});
    c := add2i(a, {0, 1});
    d := add2i(a, {1, 1});

    #assert(a.x >= 0 && a.x < size.x);
    #assert(a.y >= 0 && a.y < size.y);

    if (edge_behavior == Edge_Clamp) {
        b.x = clampi_high(size.x - 1, b.x);
        c.x = clampi_high(size.x - 1, c.x);
        d.x = clampi_high(size.x - 1, d.x);
        b.y = clampi_high(size.y - 1, b.y);
        c.y = clampi_high(size.y - 1, c.y);
        d.y = clampi_high(size.y - 1, d.y);
    } else if (edge_behavior == Edge_Wrap) {
        b.x = (b.x == size.x) ? 0 : b.x;
        c.x = (c.x == size.x) ? 0 : c.x;
        d.x = (d.x == size.x) ? 0 : d.x;
        b.y = (b.y == size.y) ? 0 : b.y;
        c.y = (c.y == size.y) ? 0 : c.y;
        d.y = (d.y == size.y) ? 0 : d.y;
    }

    A := pixels[a.x + a.y*size.x];
    B := pixels[b.x + b.y*size.x];
    C := pixels[c.x + c.y*size.x];
    D := pixels[d.x + d.y*size.x];

    AB := lerp(A, B, vf.x);
    CD := lerp(C, D, vf.x);
    ABCD := lerp(AB, CD, vf.y);

    // assert_correct_signs(A, B, C, D, AB, CD, ABCD);

    return ABCD;
}

func image_sample_nearest(img: Image*, pos: float2): Color {
    if (img.pixels == 0) {
        return {};
    }

    #assert(img.size.x);
    #assert(img.size.y);

    p := int2 { int(round(pos.x * img.size.x - 0.5 + PixelEps)), int(round(pos.y * img.size.y - 0.5 + PixelEps)) };
    return image_fetch(img, p);
}

func image_fetch(img: Image*, pos: int2): Color {
    if (img.pixels == 0 || pos.x < 0 || pos.x >= img.size.x || pos.y < 0 || pos.y >= img.size.y) {
        #assert(0);
        return {};
    }

    #assert(pos.x + pos.y*img.size.x < img.size.x*img.size.y);
    return img.pixels[pos.x + pos.y*img.size.x];
}