// Star types: *+.·˚⊹⋆✦✧✫✹✺

struct StarType {
    id: int32;
    size: float2;
    nonsquare: bool;
    fixed_rotation: bool;
    y_offset: float;
    tex: Tex;
}

enum StarTypes {
    StarType_Space = 0,
    StarType_BigSpace = 13,
    StarTypeCount
}

var star_types: StarType[StarTypeCount] = {};

struct StarsHeader {
    len: int64;
    cap: int64;
    data: Star[1];
}

struct Star {
    rect: Rect;
    type: StarType*;
    color: Color;
}

struct NebulaLayer {
    color: Color;
    scale: float;

    // per layer perturbations
    turbulence: float2;
    detail: float;
    negative_space: float;
    sparsity: float;
}

struct NebulaProperties {
    density: Tex;
    layer_count: int;
    layers: NebulaLayer*;
    turbulence: float2;
    detail: float;
    negative_space: float;
    sparsity: float;
}

struct Starfield {
    stars: Star*;
    star_count: int32;
    nebula_properties: NebulaProperties;
}

func free_starfield(starfield: Starfield*) {
    buf_free(starfield.stars);
    if (starfield.nebula_properties.density.pixels) {
        free_tex(&starfield.nebula_properties.density);
    }
    if (starfield.nebula_properties.layers) {
        buf_free(starfield.nebula_properties.layers);
    }
    starfield.stars = 0;
    starfield.star_count = 0;
}

func starfield_len(starfield: Starfield*): int64 {
    h := buf_header(starfield.stars);
    return h ? h.len / sizeof(Star) : 0;
}

func push_star(starfield: Starfield*, star: Star*) {
    buf_push((:void**)&starfield.stars, (:char*)star, sizeof(Star));
}

func consume_star(c: char const*, star: Star*): char const* {
    next := 0;
    if (*c == '\n') {
        c++;
    }

    if (*c == ' ') {
        #static_assert(StarType_Space == 0);
        star.type = star_types + StarType_Space;
        next = 1;
    } else if (*c == '*') {
        star.type = star_types + 1;
        next = 1;
    } else if (*c == '+') {
        star.type = star_types + 2;
        next = 1;
    } else if (*c == '.') {
        star.type = star_types + 3;
        next = 1;
    } else if (memcmp(c, "·", sizeof("·") - 1) == 0) {
        star.type = star_types + 4;
        next = sizeof("·") - 1;
    } else if (memcmp(c, "˚", sizeof("˚") - 1) == 0) {
        star.type = star_types + 5;
        next = sizeof("˚") - 1;
    } else if (memcmp(c, "⊹", sizeof("⊹") - 1) == 0) {
        star.type = star_types + 6;
        next = sizeof("⊹") - 1;
    } else if (memcmp(c, "⋆", sizeof("⋆") - 1) == 0) {
        star.type = star_types + 7;
        next = sizeof("⋆") - 1;
    } else if (memcmp(c, "✦", sizeof("✦") - 1) == 0) {
        star.type = star_types + 8;
        next = sizeof("✦") - 1;
    } else if (memcmp(c, "✧", sizeof("✧") - 1) == 0) {
        star.type = star_types + 9;
        next = sizeof("✧") - 1;
    } else if (memcmp(c, "✫", sizeof("✫") - 1) == 0) {
        star.type = star_types + 10;
        next = sizeof("✫") - 1;
    } else if (memcmp(c, "✹", sizeof("✹") - 1) == 0) {
        star.type = star_types + 11;
        next = sizeof("✹") - 1;
    } else if (memcmp(c, "✺", sizeof("✺") - 1) == 0) {
        star.type = star_types + 12;
        next = sizeof("✺") - 1;
    } else if (memcmp(c, "　", sizeof("　") - 1) == 0) {
        #static_assert(StarType_BigSpace == 13);
        star.type = star_types + StarType_BigSpace;
        next = sizeof("　") - 1;
    } else {
        #assert(0);
        star.type = 0;
        next = 1;
    }

    init_star_type(star.type);
    return c + next;
}

// https://en.wikipedia.org/wiki/File:TernaryColorTmap.PNG
var star_colors: Color[] = {
    { 0xff / 255., 0x01 / 255., 0.,          1. },
    { 0xff / 255., 0x0f / 255., 0.,          1. },
    { 0xff / 255., 0x29 / 255., 0x03 / 255., 1. },
    { 0xff / 255., 0x49 / 255., 0x0d / 255., 1. },
    { 0xff / 255., 0x6a / 255., 0x1f / 255., 1. },
    { 0xff / 255., 0xa6 / 255., 0x59 / 255., 1. },
    { 0xff / 255., 0xc0 / 255., 0x7f / 255., 1. },
    { 0xff / 255., 0xd8 / 255., 0xa8 / 255., 1. },
    { 0xff / 255., 0xed / 255., 0xd3 / 255., 1. },
    { 1,           1,           1,           1. },
    { 0xdb / 255., 0xe9 / 255., 0xff / 255., 1. },
    { 0x8e / 255., 0xb4 / 255., 0xff / 255., 1. },
    { 0x6e / 255., 0x9a / 255., 0xff / 255., 1. },
    { 0x45 / 255., 0x73 / 255., 0xff / 255., 1. },
    { 0x2f / 255., 0x5c / 255., 0xff / 255., 1. },
};
const StarColorCount = (sizeof(star_colors)/sizeof(Color));

func star_color(x: float): Color {
    x = clamp(0, StarColorCount - 2, x);
    xi := int(x);
    xf := x - xi;
    color := color_lerp((star_colors[xi]), (star_colors[xi + 1]), xf);
    return color;
}

func random_star_color(range: float2): Color {
    min := range.x;
    max := range.y ? range.y : StarColorCount - 1;

    offset := 8;
    r := offset + random_normal() * (StarColorCount / 7);
    x := clamp(min, max, r);

    color := star_color(x);
    return color;
}

func random_star_color_for_type(type: StarType*, alpha: float): Color {
    offset := 8;
    r := offset + random_normal() * (StarColorCount / 7);
    x := clamp(0, StarColorCount - 1, r);

    if (type.id == 12) {
        x = clamp(8, 11, x);
    }

    color := star_color(x);
    color = color_mul1(color, random01() * (float(x) / StarColorCount) * alpha);

    return color;
}

func create_starfield(starfield: char const*): Starfield {
    result: Starfield = {};

    width := 0;
    height := 0;
    line_width := 0;
    star_count := 0;

    c := starfield;
    while (*c) {
        star: Star;
        c = consume_star(c, &star);

        if (star.type) {
            if (star.type.id == StarType_BigSpace) {
                line_width += 1;
            } else if (star.type.id != StarType_Space) {
                star_count++;

                star.rect.pos = { float(line_width) + random01()*0.5-.25, float(height) + random01()*0.5-.25 + star.type.y_offset };
                x := clamp(0.66, 1.33, square(random_normal()));
                y := x;
                if (star.type.nonsquare) {
                    y = clamp(0.66, 1.33, square(random_normal()));
                }
                star.rect.size = float2 { x, y };
                star.rect.rot = star.type.fixed_rotation ? {} : random_unit_vector2();
                star.color = random_star_color_for_type(star.type, 1 + x*x);
                push_star(&result, &star);
            }
        }

        if (*c == '\n') {
            height += 6;
            width = maxi(width, line_width);
            line_width = 0;
            c++;
        } else {
            line_width += 2;
        }
    }

    width += 8;
    height += 4;

    R := maxi(width, height);
    x_pad := 4 + (R - width) / 2;
    y_pad := 4 + (R - height) / 2;

    for (i := 0; i < starfield_len(&result); i++) {
        s := result.stars + i;
        s.rect.pos.x = (ImageSize.x/ ImageSize.y) * (s.rect.pos.x + x_pad) / R;
        s.rect.pos.y = (s.rect.pos.y + y_pad) / R;
        s.rect.size.x = s.type.size.x * s.type.tex.size.x * s.rect.size.x / ImageSize.x;
        s.rect.size.y = s.type.size.y * s.type.tex.size.y * s.rect.size.y / ImageSize.y;
    }

    star_count_noise := make_tex({ 8, 8 });
    density := square(random_normal() + 2);
    for (it := pixel_iter_begin_tex(&star_count_noise, {}); pixel_iter_next(&it)) {
        // TODO: Single channel texture!
        it.pixel.r = (:float)random_poisson(exp(-clamp_low(0, density + random_normal())));
    }

    tiles := 25;
    w := (0.+ImageSize.x / ImageSize.y) / tiles;
    background_star_size := 0.005;
    xy := float2 { (w * ImageSize.x / ImageSize.y) / 2., w / 2. };
    for (i := 0; i < tiles ; i++) {
        for (j := 0; j < tiles; j++) {
            count := max(1., tex_lookup(&star_count_noise, xy).r);
            for (k := 0; k < count; k++) {
                size := max(1. / ImageSize.x, random_normal()*background_star_size*(1 + count - int(count)));

                push_star(&result, &{
                    rect = {
                        pos = add2(xy, {(random01() - 0.5) * w, (random01() - 0.5) * w}),
                        size = { size, size },
                        rot = random_unit_vector2()
                    },
                    type = star_types + 1,
                    color = random_star_color_for_type(star_types + 1, 3*size*(16+4*count))
                });
            }

            xy.x += w;
        }

        xy.x = w / 2;
        xy.y += w;
    }


    turbulence := randomr(0., 0.2);
    result.nebula_properties = {
        density = star_count_noise,
        turbulence = { turbulence, randomr(turbulence, 0.35) },
        detail = clamp_low(-1, random_normal() * 2),
        negative_space = (random() & 1) ? 1. : -1.,
        sparsity = randomr(0.4, 1),
    };

    scales : float[4] = {1,1.5,1.75,2};

    layer_count := 3; //clampi(0, 4, random_poisson(exp(-2.1)));
    color_x := randomr(2, StarColorCount - 2);
    variability := randomr(0.05, .3);
    color_width := variability*StarColorCount/1.5;
    for (i := 0; i < layer_count; i++) {
        buf_push((:void**)&result.nebula_properties.layers, &NebulaLayer {
            color = star_color(color_x + random_normal()*color_width),
            scale = scales[i],
            turbulence = {},
            detail = random_normal()*variability*3,
            negative_space = 1,
            sparsity = random_normal()*variability*.1,
        }, sizeof(NebulaLayer));
    }
    result.nebula_properties.layer_count = layer_count;

    result.star_count = (:int)starfield_len(&result);
    return result;
}


func draw_simple_star(tex: Tex*) {
    tex_write_nearest(tex, { .5, .5 }, { 64, 64, 64, 1 });
}

func draw_galaxy(tex: Tex*, arms: int) {
    tex_img := &Image { tex.pixels, tex.size };

    arm_width := 0.0125 + randomr(-1, 1)*0.01;
    arms = clampi(2, 6, arms);
    brightness := randomr(0.8, 1.1);
    arm_definition := randomr(1./arms, 1);
    bar := randomr(.05, .25) / arms;
    spiral_expansion := randomr(1,1.3);
    tilt := random01();

    s := &Starfield {};
    buf_fit((:void**)&s.stars, sizeof(Star)*30000);
    for (i := 0; i < 30000; i++) {
        w := arm_width;
        x := random_normal() / 8;
        y := random_normal() / 8;
        rot := 0.;

        if (arms > 0) {
            x = mod(x + w/2, w) - w/2;

            if (arms & 1) {
                y = fabs(y);
            }

            rot = randomn(0, arms) / float(arms);
            rot += random_normal() * 0.05 * (1 - arm_definition);

            x += (random_normal() / 256) * (1 - arm_definition);
            y += (random_normal() / 256) * (1 - arm_definition);
        }

        // Rotate the arms more towards the edge
        mag := magnitude2({x, y}) + 0.05*random_normal();
        xy := mul2s(normalise2({ x, y }), mag);
        expand := exp(spiral_expansion*(1+mag));
        spin := (random_normal() / 12 + 1)*mag*expand;

        // Bar
        spin *= smoothedge(bar, randomr(.1, .3), mag);

        // Arms
        spin += rot;

        spiral_str := mul2s({ cos(spin * Tau), sin(spin * Tau) }, .5*expand);
        pos := rotate(xy, spiral_str);

        // Fake 3D
        z := (random_normal() * 0.01) * (1 - tilt);
        pos.y *= tilt;
        pos.y += .25 * z;

        // Dim large/bright stars towards the edge
        size := (Sqrt2 - magnitude2(pos) + z + y * tilt) * random01() * 0.016 * brightness;

        push_star(s, &{
            rect = {
                pos = add2s(mul2s(pos, .51), 0.5),
                size = { size, size },
                rot = random_unit_vector2()
            },
            type = star_types + 1,
            color = random_star_color_for_type(star_types + 1, 0.66)
        });
    }

    draw_stars(tex_img, s);

    bloom_less := image_copy(tex_img);
    bloom_more := image_copy(tex_img);
    blur(&bloom_less, 3);
    blur(&bloom_more, 20 * tilt);
    bloom_amount := randomr(.4, .8);

    blue := star_colors[StarColorCount - 3];
    yellow := star_colors[5];

    for (it := pixel_iter_begin_tex(tex, {}); pixel_iter_next(&it)) {
        rel := sub2s(it.pos, 0.5);
        th := magnitude2(rel);
        bl := image_sample_linear(&bloom_less, it.pos);
        bm := image_sample_linear(&bloom_more, it.pos);

        center_yellow_str := pow(1 - clamp01(th / (Sqrt2/4)), 6);
        arm_color := color_lerp(blue, yellow, center_yellow_str);
        inter_color := color_mul1_rgb(color_mul(arm_color, bm), perlin_octaves(it.pos, 40) * 0.5 + 1);
        matter := color_mul(bl, arm_color);
        matter = color_mul1_rgb(matter, perlin_octaves(it.pos, 32) * 0.5 + 1);
        matter = color_add(inter_color, matter);
        matter.a = clamp01(max(matter.r, max(matter.g, matter.b))) * bloom_amount;

        *it.pixel = color_blend(*it.pixel, color_premultiply(matter));
    }

    free_starfield(s);
    free_image(&bloom_less);
    free_image(&bloom_more);
}

func draw_lensed_quasar(tex: Tex*) {
    center := div2si(tex.size, 2);

    width := tex.size.x / int(2 + random01() * 8);
    height := tex.size.y / int(2 + random01() * 8);

    top := sub2i(center, { width, 0 });
    right := add2i(center, { 0, height });
    bottom := add2i(center, { width, 0 });
    left := sub2i(center, { 0, height });

    lum := Color { 16., 16., 16., 1. };

    tex.pixels[center.x + tex.size.x*center.y] = { lum.r, lum.g, lum.b * 1.25, lum.a };
    blur(&{ tex.pixels, tex.size }, 2);

    tex_poke(tex, top, lum);
    tex_poke(tex, right, lum);
    tex_poke(tex, bottom, lum);
    tex_poke(tex, left, lum);

    blur(&{ tex.pixels, tex.size }, .25);
    blur(&{ tex.pixels, tex.size }, .25);
}

func init_star_type(type: StarType*) {
    init_star_type_really(type, false);
}

func init_star_type_really(type: StarType*, redraw: bool) {
    idx := (:int32)(type - star_types);
    #assert(idx >= 0);
    #assert(idx < StarTypeCount);

    if (type.tex.pixels) {
        if (redraw == false) {
            #assert(type.tex.size.x != 0);
            #assert(type.tex.size.y != 0);
            return;
        }

        free_tex(&type.tex);
    }

    type.id = idx;

    switch (idx) {
        case 0:
            type.tex = make_tex({ 8, 8 });
            type.size = { 1, 1 };
            draw_outline(type.tex.pixels, type.tex.size, { 0, 1, 0, 0.5 });
        case 1: // *
            type.tex = make_tex({ 64, 64});
            type.size = { 1, 1 };
            type.y_offset = .25;
            draw_simple_star(&type.tex);
        case 2: // +
            type.tex = make_tex({ 128, 128 });
            type.size = { .5, .5 };
            type.fixed_rotation = true;
            draw_simple_star(&type.tex);
            blur(&{type.tex.pixels, type.tex.size}, .1);
            diffract(&{type.tex.pixels, type.tex.size}, { alpha = 8., radius = 8, transform = diffraction_rotation, type = Diffraction_Cross });
            blur(&{type.tex.pixels, type.tex.size}, .1);
        case 3: // .
            type.tex = make_tex({ 32, 32 });
            type.size = { 1, 1 };
            type.y_offset = -66.;
            draw_simple_star(&type.tex);
        case 4: // ·
            type.tex = make_tex({ 32, 32 });
            type.size = { 1, 1 };
            draw_simple_star(&type.tex);
        case 5: // ˚
            type.tex = make_tex({ 64, 64 });
            type.size = { 1, 1 };
            type.y_offset = .66;
            draw_simple_star(&type.tex);
        case 6: // ⊹
            type.tex = make_tex({ 64,  64 });
            type.size = { .5, .5 };
            type.y_offset = -.1;
            draw_lensed_quasar(&type.tex);
        case 7: // ⋆
            type.tex = make_tex({ 64, 64 });
            type.size = { 1, 1 };
            type.fixed_rotation = true;
            draw_simple_star(&type.tex);
            diffract(&{type.tex.pixels, type.tex.size}, { alpha = 2, radius = 1.5, transform = rotate(diffraction_rotation, { InvSqrt2, InvSqrt2 }) });
            diffract(&{type.tex.pixels, type.tex.size}, { alpha = 1, radius = 1.5, transform = rotate(diffraction_rotation, { cos(Pi/8), sin(Pi/8)}) });
        case 8: // ✦
            type.tex = make_tex({ 64, 64 });
            type.size = { 1, 1 };
            draw_simple_star(&type.tex);
            blur(&{type.tex.pixels, type.tex.size}, .5);
            diffract(&{type.tex.pixels, type.tex.size}, { alpha = 3, radius = 1.75, transform = rotate(diffraction_rotation, { InvSqrt2, InvSqrt2 }) });
            diffract(&{type.tex.pixels, type.tex.size}, { alpha = 2, radius = 1.75, transform = rotate(diffraction_rotation, { cos(Pi/4), sin(Pi/4)}) });
        case 9: // ✧
            type.tex = make_tex({ 64, 64 });
            type.size = { 1, 1 };
            type.fixed_rotation = true;
            draw_simple_star(&type.tex);
            diffract(&{type.tex.pixels, type.tex.size}, { 2, 2, diffraction_rotation });
        case 10: // ✫
            type.tex = make_tex({ 128, 128 });
            type.size = { 1, 1 };
            type.fixed_rotation = true;

            type.tex.pixels[((type.tex.size.x)/2 - 1) + ((type.tex.size.y)/2 - 1)*(type.tex.size.x)] = { 64, 16, 1, 1 };
            img := image_copy(&Image { type.tex.pixels, type.tex.size });
            diffract(&img, { 1, 2, rotate(diffraction_rotation, { InvSqrt2, InvSqrt2 }) });
            blur(&img, 0.1);
            for (it := pixel_iter_begin_tex(&type.tex, {}); pixel_iter_next(&it)) {
                c := image_sample_nearest(&img, it.pos);
                str := clamp01(1 - magnitude2(sub2(it.pos, { 0.5, 0.5 })) * 12);
                str = str*str*str*str*str;
                to_white := color_lerp({1, 1, 1, 1}, { 1, 4, 64, 1 }, str);
                *it.pixel = color_add(*it.pixel, color_mul(c, to_white));
            }
        case 11: // ✹
            type.tex = make_tex({ 64, 64 });
            type.size = { 1, 1 };
        case 12: // ✺
            type.tex = make_tex({ 256, 256 });
            type.size = { 1./3., 1./3. };
            type.nonsquare = true;
            draw_galaxy(&type.tex, randomn(1,8));
        case 13: // '　'
            type.tex = make_tex({ 8, 8 });
            type.size = { 1, 1 };
            draw_outline(type.tex.pixels, type.tex.size, { 1, 0, 0, 0.5 });
        default: {
            type.tex = make_tex({ 32, 32});
            type.size = { 1, 1 };
            draw_simple_star(&type.tex);
        }
    }

    tex_preprocess(&type.tex);
}

func rwo_gradient(p: int2): float2 {
    // bad_hash_int2 with fnv-32 values so it gives the same results as the sse version
    h := (((0x811c9dc5 ^ uint(p.x)) * 16777619u) ^ uint(p.y)) * 16777619u;
    a := xor_shift(h);
    b := float_from_random_bits(a);

    // Generate a random direction (x, y). (sqrt(b), sqrt(1 - b)) follows from
    // the usual (b, sqrt(1 - b*b)), but we take the sqrt of b for x for two
    // reasons. Firstly, the two sqrts seems to fare better speed wise--possibly
    // due to pipelining? Secondly, if we generate y from a uniform x, then x is
    // uniformly distributed on the unit interval, *not* the x part of the unit
    // circle. sqrt(b) pushes the points in (0,1) towards 1, to be more
    // cosine-weighted-like, so it's slightly better (but still worse than
    // sincos(pi*X)). Another option is randomly swapping x and y, but that
    // tanks throughput.
    x := sqrt(b);
    y := sqrt(1 - b);

    // This positive in both x and y, but we don't use all the bits in a to
    // generate the random float, so we use those to dump it in some quadrant
    // of the unit circle.
    x_sign := a & (1<<31);
    y_sign := (a<<1) & (1<<31);
    xx := fbits{i = (fbits{f=x}.i + x_sign)}.f;
    yy := fbits{i = (fbits{f=y}.i + y_sign)}.f;

    return { xx, yy };
}

func random_warp_one(p: float2, scale: float): float2 {
    a := rwo_gradient(float2_to_int2(add2(p, { 0, 0 })));
    b := rwo_gradient(float2_to_int2(add2(p, { 1, 0 })));
    c := rwo_gradient(float2_to_int2(add2(p, { 0, 1 })));
    d := rwo_gradient(float2_to_int2(add2(p, { 1, 1 })));
    r := float2 { p.x - int(p.x), p.y - int(p.y) };

    x := r.x*r.x*(3. - 2.*r.x);
    y := r.y*r.y*(3. - 2.*r.y);

    ab := lerp2(a, b, x);
    cd := lerp2(c, d, x);
    abcd := lerp2(ab, cd, y);

    return mul2s(abcd, scale);
}

func random_warp_scalar(p: float2, freq: float, scale: float): float2 {
    a := 1.;
    b := a*.5;
    c := b*.5;
    d := c*.5;

    q := mul2s(p, freq);
    return add2(p, mul2s(add2(random_warp_one(q, a),
                         add2(random_warp_one(mul2s(q, 2), b),
                         add2(random_warp_one(mul2s(q, 4), c),
                              random_warp_one(mul2s(q, 8), d)))),
                    scale / (a+b+c+d)));
}

struct float4x2 {
    x: float4;
    y: float4;
}

func rwo_gradient_sse(px: float4, py: float4): float4x2 {
    pxi := float4_to_int4(px);
    pyi := float4_to_int4(py);
    H0 := set4si(0x811c9dc5);
    H1 := set4si(16777619);
    h := mul4i(xor4i(mul4i(xor4i(pxi, H0), H1), pyi), H1);
    a := xor4i(h, shl4si(h, 13));
    a  = xor4i(a, shr4si(a, 17));
    a  = xor4i(a, shl4si(a, 5));
    b := cast_int4_to_float4(or4i(and4i(a, set4si(f_sig_mask)), set4si(f_exp_1_2_mask)));
    c := sub4(b, set4s(1));
    x := sqrt4(c);
    y := sqrt4(sub4(set4s(1), c));

    x_sign := and4i(a, set4si(1 << 31));
    y_sign := and4i(shl4si(a, 1), set4si(1 << 31));

    return { cast_int4_to_float4(add4i(cast_float4_to_int4(x), x_sign)), cast_int4_to_float4(add4i(cast_float4_to_int4(y), y_sign)) };
}


func random_warp_sse(p: float2, freq: float, scale: float): float2 {
    one := set4s(1.);
    two := set4s(2.);
    three := set4s(3.);

    scale4 := set4(0.125, 0.25, 0.5, 1);
    octave := set4(8, 4, 2, 1);

    qx := mul4(set4s(p.x * freq), octave);
    qy := mul4(set4s(p.y * freq), octave);
    qxi := floor4(qx);
    qyi := floor4(qy);
    qxi1 := add4(qxi, one);
    qyi1 := add4(qyi, one);

    a := rwo_gradient_sse(qxi, qyi);
    b := rwo_gradient_sse(qxi1, qyi);
    c := rwo_gradient_sse(qxi, qyi1);
    d := rwo_gradient_sse(qxi1, qyi1);

    rx := sub4(qx, qxi);
    ry := sub4(qy, qyi);

    x := mul4(mul4(rx, rx), sub4(three, mul4(rx, two)));
    y := mul4(mul4(ry, ry), sub4(three, mul4(ry, two)));

    abx := lerp4(a.x, b.x, x);
    aby := lerp4(a.y, b.y, x);
    cdx := lerp4(c.x, d.x, x);
    cdy := lerp4(c.y, d.y, x);
    abcdx := mul4(lerp4(abx, cdx, y), scale4);
    abcdy := mul4(lerp4(aby, cdy, y), scale4);

    xy01 := unpacklo4(abcdx, abcdy);
    xy23 := unpackhi4(abcdx, abcdy);

    xyxy := add4(xy01, xy23);
    x_y_ := unpackhi4(xyxy, xyxy);

    offset := add4(xyxy, x_y_);

    p4 := set4(0, 0, p.y, p.x);
    result4 := add4(p4, mul4s(offset, scale / (1 + 0.5 + 0.25 + 0.125)));

    // Dumb, but the compiler does the right thing.
    result: float2[2] = {};
    storeu4((:float*)result, result4);
    return result[0];
}

func random_warp(p: float2, freq: float, scale: float): float2 {
    return random_warp_sse(p, freq, scale);
}

func draw_nebula(img: Image*, props: NebulaProperties*, layer: NebulaLayer*) {
    nebula := make_image_like(img, 1);

    color := layer.color;
    scale := layer.scale;

    density := &props.density;
    turbulence  := props.turbulence.x * scale;
    turbulence2 := props.turbulence.y * scale;
    detail := props.detail * scale;
    negative_space := props.negative_space;
    sparsity := props.sparsity;

    for (it := pixel_iter_begin(&nebula, {}); pixel_iter_next(&it)) {
        d := tex_lookup(density, it.pos).r * .1;
        p := perlin_octaves(it.abs_pos, 5) * .5 + .5;
        warp_scale := d * turbulence*(1 - p);
        w1 := worley_octaves(random_warp(add2s(it.abs_pos, 1.6939), 4, warp_scale), 5+p*0.2).x;
        w2 := worley_octaves(random_warp(add2s(it.abs_pos, 3.32849), 6 + 5*turbulence2, warp_scale), 7+p*0.2).y;
        w3 := 4*worley_octaves(random_warp(add2s(it.abs_pos, 8.22643), 10 + 10*turbulence2, warp_scale), 10 + detail+p*0.2).y;
        w := w1*w1*w2*w3;
        *it.pixel = color_mul1(color, clamp_low(0.08, w*p));
    }

    blur_nebula := make_image_like(&nebula, 4);
    image_copy_to(&blur_nebula, &nebula);
    blur_region(&blur_nebula, 16);

    for (it := pixel_iter_begin(img, {}); pixel_iter_next(&it)) {
        d := tex_lookup(density, it.pos).r * 0.05;
        n := image_sample_linear(&nebula, it.pos);
        nb := image_sample_linear(&blur_nebula, it.pos);
        nnb := color_mul(n, nb);
        x := color_lerp(n, nnb, sparsity);
        y := color_add(n, x);
        z := color_pow(y, 2 + d * negative_space);
        z.a *= .333;

        *it.pixel = color_blend(*it.pixel, color_premultiply(z));
    }

    free_image(&nebula);
    free_image(&blur_nebula);
}

func draw_stars(dest: Image*, starfield: Starfield*) {
    for (i := starfield_len(starfield) - 1; i >= 0; i--) {
        star := starfield.stars + i;
        draw_tex_multiply(dest, star.rect, &star.type.tex, star.color);
    }
}

func draw_starfield(dest: Image*, starfield: Starfield*) {
    draw_stars(dest, starfield);
    for (i := 0; i < starfield.nebula_properties.layer_count; i++) {
        draw_nebula(dest, &starfield.nebula_properties, starfield.nebula_properties.layers + i);
    }
}