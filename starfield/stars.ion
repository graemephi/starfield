// Star types: *+.·˚⊹⋆✦✧✫✹✺

struct StarType {
    id: int32;
    size: float2;
    nonsquare: bool;
    random_rotation: bool;
    y_offset: float;
    tex: Tex;
}

enum StarTypes {
    StarType_None = 0,
    StarType_Space = 1,
    StarType_BigSpace = 14,
    StarTypeCount
}

struct Star {
    type: StarType*;
    rect: Rect;
    color: Color;
}

struct NebulaLayer {
    color: Color;
    scale: float;

    // per layer perturbations
    turbulence: float2;
    detail: float;
    negative_space: float;
    sparsity: float;
}

struct NebulaProperties {
    density: Tex;
    layer_count: int;
    layers: NebulaLayer[];
    turbulence: float2;
    detail: float;
    negative_space: float;
    sparsity: float;
}

struct Starfield {
    types: StarType[StarTypeCount];
    stars: Star[];
    nebula_properties: NebulaProperties;
}

func free_starfield(starfield: Starfield*) {
    for (i := 0; i < StarTypeCount; i++) {
        if (starfield.types[i].tex.pixels) {
            free_tex(&starfield.types[i].tex);
        }
    }
    if (starfield.stars) {
        afree(starfield.stars);
    }
    if (starfield.nebula_properties.density.pixels) {
        free_tex(&starfield.nebula_properties.density);
    }
    if (starfield.nebula_properties.layers) {
        afree(starfield.nebula_properties.layers);
    }
    starfield.stars = 0;
}

func consume_utf8_character(c: char const*, out: int*): char const* {
    if (*c & 0x80 == 0) {
        *out = *c;
        return c + 1;
    } else if (*c & 0xE0 == 0xC0) {
        *out = (c[1] << 8) + c[0];
        return c + 2;
    } else if (*c & 0xF0 == 0xE0) {
        *out = (c[2] << 16) + (c[1] << 8) + c[0];
        return c + 3;
    }

    #assert(*c & 0xF0 == 0xF0);
    *out = (c[3] << 24) + (c[2] << 16) + (c[1] << 8) + c[0];
    return c + 4;
}

@inline
func decode_utf8(c: char const*): int {
    if (*c & 0x80 == 0) {
        return *c;
    } else if (*c & 0xE0 == 0xC0) {
        return (c[1] << 8) + c[0];
    } else if (*c & 0xF0 == 0xE0) {
        return (c[2] << 16) + (c[1] << 8) + c[0];
    }

    #assert(*c & 0xF0 == 0xF0);
    return (c[3] << 24) + (c[2] << 16) + (c[1] << 8) + c[0];
}

func consume_star(c: char const*, id: int*): char const* {
    while (*c == '\n') {
        c++;
    }

    ch: int;
    c = consume_utf8_character(c, &ch);

    if (ch == ' ') {
        *id = StarType_Space;
    } else if (ch == '*') {
        *id = 2;
    } else if (ch == '+') {
        *id = 3;
    } else if (ch == '.') {
        *id = 4;
    } else if (ch == decode_utf8("·")) {
        *id = 5;
    } else if (ch == decode_utf8("˚")) {
        *id = 6;
    } else if (ch == decode_utf8("⊹")) {
        *id = 7;
    } else if (ch == decode_utf8("⋆")) {
        *id = 8;
    } else if (ch == decode_utf8("✦")) {
        *id = 9;
    } else if (ch == decode_utf8("✧")) {
        *id = 10;
    } else if (ch == decode_utf8("✫")) {
        *id = 11;
    } else if (ch == decode_utf8("✹")) {
        *id = 12;
    } else if (ch == decode_utf8("✺")) {
        *id = 13;
    } else if (ch == decode_utf8("　")) {
        #static_assert(StarType_BigSpace == 14);
        *id = StarType_BigSpace;
    } else {
        #assert(0);
        *id = 0;
    }

    return c;
}

func get_star_type(starfield: Starfield*, id: int): StarType* {
    type := &starfield.types[id];
    if (type.id != StarType_None) {
        return type;
    }
    init_star_type(type, id);
    return type;
}

func init_star_type(type: StarType*, id: int) {
    #assert(id >= 0);
    #assert(id < StarTypeCount);

    if (type.tex.pixels) {
        free_tex(&type.tex);
    }

    type.id = id;

    switch (id) {
        case 1: // ' '
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_outline(type.tex.pixels, type.tex.size, { 0, 1, 0, 0.5 });
        case 2: // *
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            type.y_offset = .25;
            draw_simple_star(&type.tex, 64);
        case 3: // +
            type.tex = make_tex({ 32, 32 });
            type.size = { .1, .1 };
            draw_simple_star(&type.tex, 64);
        case 4: // .
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            type.y_offset = -.66;
            draw_simple_star(&type.tex, 64);
        case 5: // ·
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_simple_star(&type.tex, 64);
        case 6: // ˚
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            type.y_offset = .66;
            draw_simple_star(&type.tex, 64);
        case 7: // ⊹
            type.tex = make_tex({ 64,  64 });
            type.size = { 16, 16 };
            type.y_offset = -.1;
            draw_lensed_quasar(&type.tex);
        case 8: // ⋆
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_simple_star(&type.tex, 64);
        case 9: // ✦
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_simple_star(&type.tex, 64);
            blur_tex(&type.tex, .5);
        case 10: // ✧
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_simple_star(&type.tex, 64);
        case 11: // ✫
            type.tex = make_tex({ 128, 128 });
            type.size = { 128, 128 };

            type.tex.pixels[((type.tex.size.x)/2 - 1) + ((type.tex.size.y)/2 - 1)*(type.tex.size.x)] = { 64, 16, 1, 1 };
            img := tex_image_copy(&type.tex);
            diffract(&img, { {1,1,1,1}, {2,2,2,2}, rotate(diffraction_rotation, { InvSqrt2, InvSqrt2 }) });
            blur(&img, 0.1);
            for (it := pixel_iter_begin_tex(&type.tex, {}); pixel_iter_next(&it)) {
                c := image_sample_nearest(&img, it.pos);
                str := clamp01(1 - magnitude2(sub2(it.pos, { 0.5, 0.5 })) * 12);
                str = str*str*str*str*str;
                to_white := color_lerp({1, 1, 1, 1}, { 1, 4, 64, 1 }, str);
                *it.pixel = color_add(*it.pixel, color_mul(c, to_white));
            }
        case 12: // ✹
            type.tex = make_tex({ 32, 32 });
            type.size = { 32, 32 };
            draw_simple_star(&type.tex, 64);
        case 13: // ✺
            type.tex = make_tex({ 256, 256 });
            type.size = { 96, 96 };
            type.nonsquare = true;
            type.random_rotation = true;
            draw_galaxy(&type.tex, randomn(1,8));

            // Reveal rendering bug:
            // draw_outline(type.tex.pixels, type.tex.size, { 0, 1, 0, 0.5 });
        case 14: // '　'
            type.tex = make_tex({ 8, 8 });
            type.size = { 32, 32 };
            draw_outline(type.tex.pixels, type.tex.size, { 1, 0, 0, 0.5 });
    }

    tex_preprocess(&type.tex);
}

// https://en.wikipedia.org/wiki/File:TernaryColorTmap.PNG
var star_colors: Color[] = {
    { 0,           0,           0,              },
    { 0xff / 255., 0x01 / 255., 0.,          1. },
    { 0xff / 255., 0x0f / 255., 0.,          1. },
    { 0xff / 255., 0x29 / 255., 0x03 / 255., 1. },
    { 0xff / 255., 0x49 / 255., 0x0d / 255., 1. },
    { 0xff / 255., 0x6a / 255., 0x1f / 255., 1. },
    { 0xff / 255., 0xa6 / 255., 0x59 / 255., 1. },
    { 0xff / 255., 0xc0 / 255., 0x7f / 255., 1. },
    { 0xff / 255., 0xd8 / 255., 0xa8 / 255., 1. },
    { 0xff / 255., 0xed / 255., 0xd3 / 255., 1. },
    { 1,           1,           1,           1. },
    { 0xdb / 255., 0xe9 / 255., 0xff / 255., 1. },
    { 0x8e / 255., 0xb4 / 255., 0xff / 255., 1. },
    { 0x6e / 255., 0x9a / 255., 0xff / 255., 1. },
    { 0x45 / 255., 0x73 / 255., 0xff / 255., 1. },
    { 0x2f / 255., 0x5c / 255., 0xff / 255., 1. },
};
const StarColorCount = (sizeof(star_colors)/sizeof(Color));

func star_color(x: float): Color {
    x = clamp(1, StarColorCount - 2, x);
    xi := int(x);
    xf := x - xi;
    color := color_lerp((star_colors[xi]), (star_colors[xi + 1]), xf);
    return color;
}

func random_star_color(range: float2): Color {
    min := range.x;
    max := range.y ? range.y : StarColorCount - 1;

    offset := 8;
    r := offset + random_normal() * (StarColorCount / 7);
    x := clamp(min, max, r);

    color := star_color(x);
    return color;
}

func random_star_color_for_type(type: StarType*, alpha: float): Color {
    offset := 9;
    r := offset + random_normal() * (StarColorCount / 7);
    x := clamp(0, StarColorCount - 1, r);

    if (type.id == 13) {
        x = clamp(9, 12, x);
    }

    color := star_color(x);
    color = color_mul1(color, random01() * (float(x) / StarColorCount) * alpha);

    return color;
}

func create_starfield(starfield_text: char const*): Starfield {
    starfield: Starfield = {};

    aspect_ratio := float(ImageSize.x) / float(ImageSize.y);
    star_size_mod := square(square(random01()));
    star_size := exp(-6 + star_size_mod); // 0.005

    width := 0;
    height := 0;
    line_width := 0;

    c := starfield_text;
    while (*c) {
        type_id: int;
        c = consume_star(c, &type_id);
        type := get_star_type(&starfield, type_id);

        if (type.id) {
            if (type.id == StarType_BigSpace) {
                line_width += 1;
            } else if (type.id != StarType_Space) {
                star := Star { type = type };
                star.rect.pos = { aspect_ratio * float(line_width) + random01()*0.5-.25, float(height) + random01()*0.5-.25 + star.type.y_offset };
                x := star_size * clamp(0.8, 1., square(random_normal())) * star.type.size.x;
                y := star.type.nonsquare ? (star_size * clamp(0.8, 1., square(random_normal())) * star.type.size.y) : x;
                star.rect.size = float2 { x, y };
                star.rect.rot = star.type.random_rotation ? random_unit_vector2() : diffraction_rotation;
                star.color = random_star_color_for_type(star.type, .5 + sqrt(x));

                apush(starfield.stars, star);
            }
        }

        if (*c == '\n') {
            height += 6;
            width = maxi(width, line_width);
            line_width = 0;
            c++;
        } else {
            line_width += 2;
        }
    }

    width += 8;
    height += 4;

    R := maxi(width, height);
    x_pad := 4 + (R - width) / 2;
    y_pad := 4 + (R - height) / 2;

    for (i := 0; i < alen(starfield.stars); i++) {
        s := starfield.stars + i;
        s.rect.pos.x = (s.rect.pos.x + x_pad) / R;
        s.rect.pos.y = (s.rect.pos.y + y_pad) / R;
    }

    star_count_noise := make_tex({ 8, 8 });
    density := square(random_normal() + 2);
    for (it := pixel_iter_begin_tex(&star_count_noise, {}); pixel_iter_next(&it)) {
        // TODO: Single channel texture!
        it.pixel.r = (:float)random_poisson(exp(-clamp_low(0, density + random_normal())));
    }

    tiles := 25;
    w := 1. / tiles;
    xy := float2 {};
    for (i := 0; i < tiles; i++) {
        for (j := 0; j < tiles*aspect_ratio; j++) {
            count := max(1., tex_lookup(&star_count_noise, xy).r);
            for (k := 0; k < count; k++) {
                size := clamp_low(star_size, random_normal()*star_size*(1 + count - int(count)));

                apush(starfield.stars, {
                    rect = {
                        pos = add2(xy, { random01() * w, random01() * w }),
                        size = { size, size }
                    },
                    type = &starfield.types[2],
                    color = random_star_color_for_type(&starfield.types[2], 3*size*(16+4*count))
                });
            }

            xy.x += w;
        }

        xy.x = 0;
        xy.y += w;
    }


    turbulence := randomr(0., 0.2);
    starfield.nebula_properties = {
        density = star_count_noise,
        turbulence = { turbulence, randomr(turbulence, 0.35) },
        detail = clamp_low(-1, random_normal() * 2),
        negative_space = (random() & 1) ? 1. : -1.,
        sparsity = randomr(0.4, 1),
    };

    scales: float[] = {1,1.5,1.75,2,2.4,2.7,3.4,4.};

    layer_count := clampi(0, sizeof(scales)/sizeof(scales[0]), random_poisson(exp(-1.8)));
    color_x := randomr(2, StarColorCount - 2);
    variability := randomr(0.05, .3);
    color_width := variability*StarColorCount/1.5;
    for (i := 0; i < layer_count; i++) {
        apush(starfield.nebula_properties.layers, NebulaLayer {
            color = star_color(color_x + random_normal()*color_width),
            scale = scales[i],
            turbulence = {},
            detail = random_normal()*variability*3,
            negative_space = 1,
            sparsity = random_normal()*variability*.1,
        });
    }
    starfield.nebula_properties.layer_count = layer_count;

    return starfield;
}


func draw_simple_star(tex: Tex*, luminance: float) {
    tex_write_nearest(tex, { .5, .5 }, { luminance, luminance, luminance, 1 });
}

func draw_galaxy(tex: Tex*, arms: int) {
    tex_img := tex_image(tex);

    arm_width := 0.0125 + randomr(-1, 1)*0.01;
    arms = clampi(2, 6, arms);
    brightness := randomr(0.8, 1.1);
    arm_definition := randomr(1./arms, 1);
    bar := randomr(.05, .25) / arms;
    spiral_expansion := randomr(1,1.3);
    tilt := random01();

    s := &Starfield {};
    star_type := get_star_type(s, 2);
    afit(s.stars, 30000);
    for (i := 0; i < 30000; i++) {
        w := arm_width;
        x := random_normal() / 8;
        y := random_normal() / 8;
        rot := 0.;

        if (arms > 0) {
            x = repeat(x + w/2, w) - w/2;

            if (arms & 1) {
                y = fabs(y);
            }

            rot = randomn(0, arms) / float(arms);
            rot += random_normal() * 0.05 * (1 - arm_definition);

            x += (random_normal() / 256) * (1 - arm_definition);
            y += (random_normal() / 256) * (1 - arm_definition);
        }

        // Rotate the arms more towards the edge
        mag := magnitude2({x, y}) + 0.05*random_normal();
        xy := mul2s(normalise2({ x, y }), mag);
        expand := exp(spiral_expansion*(1+mag));
        spin := (random_normal() / 12 + 1)*mag*expand;

        // Bar
        spin *= smoothedge(bar, randomr(.1, .3), mag);

        // Arms
        spin += rot;

        spiral_str := mul2s({ cos(spin * Tau), sin(spin * Tau) }, .5*expand);
        pos := rotate(xy, spiral_str);

        // Fake 3D
        z := (random_normal() * 0.01) * (1 - tilt);
        pos.y *= tilt;
        pos.y += .25 * z;

        // Dim large/bright stars towards the edge
        size := (Sqrt2 - magnitude2(pos) + z + y * tilt) * random01() * 0.016 * brightness;

        apush(s.stars, {
            rect = {
                pos = add2s(mul2s(pos, 0.5), 0.5),
                size = { size, size }
            },
            type = star_type,
            color = random_star_color_for_type(star_type, 0.66)
        });
    }

    draw_stars(&tex_img, s);

    bloom_less := blur_to_copy(&tex_img, 3);
    bloom_more := blur_to_copy(&tex_img, 20 * tilt);
    bloom_amount := randomr(.4, .8);

    blue := star_colors[StarColorCount - 3];
    yellow := star_colors[6];

    for (it := pixel_iter_begin_tex(tex, {}); pixel_iter_next(&it)) {
        rel := sub2s(it.pos, 0.5);
        th := magnitude2(rel);
        bl := image_sample_linear(&bloom_less, it.pos);
        bm := image_sample_linear(&bloom_more, it.pos);

        center_yellow_str := pow(1 - clamp01(th / (Sqrt2/4)), 6);
        arm_color := color_lerp(blue, yellow, center_yellow_str);
        inter_color := color_mul1_rgb(color_mul(arm_color, bm), perlin_octaves(it.pos, 40) * 0.5 + 1);
        matter := color_mul(bl, arm_color);
        matter = color_mul1_rgb(matter, perlin_octaves(it.pos, 32) * 0.5 + 1);
        matter = color_add(inter_color, matter);
        matter.a = clamp01(max(matter.r, max(matter.g, matter.b))) * bloom_amount;

        *it.pixel = color_blend(*it.pixel, color_premultiply(matter));
    }

    free_starfield(s);
    free_image(&bloom_less);
    free_image(&bloom_more);
}

func draw_lensed_quasar(tex: Tex*) {
    center := div2si(tex.size, 2);

    width := tex.size.x / 16;
    height := width + int(random_normal()/6);
    top := sub2i(center, { width, 0 });
    right := add2i(center, { 0, height });
    bottom := add2i(center, { width, 0 });
    left := sub2i(center, { 0, height });

    lum := Color { 16., 16., 20., 1. };

    tex.pixels[center.x + tex.size.x*center.y] = lum;
    blur_tex(tex, 2);

    tex_poke(tex, top, lum);
    tex_poke(tex, right, lum);
    tex_poke(tex, bottom, lum);
    tex_poke(tex, left, lum);
}

func draw_nebula(img: Image*, props: NebulaProperties*, layer: NebulaLayer*) {
    nebula := make_uninitialised_image_like(img);

    color := layer.color;
    scale := layer.scale;

    density := &props.density;
    turbulence  := props.turbulence.x * scale;
    turbulence2 := props.turbulence.y * scale;
    detail := props.detail * scale;
    negative_space := props.negative_space;
    sparsity := props.sparsity;

    for (it := pixel_iter_begin(&nebula, {}); pixel_iter_next(&it)) {
        d := tex_lookup(density, it.pos).r * .1;
        p := perlin_octaves(it.pos, 5) * .5 + .5;
        warp_scale := d * turbulence*(1 - p);
        w1 := worley_octaves(random_warp(add2s(it.pos, 1.6939), 4, warp_scale), 5+p*0.2).x;
        w2 := worley_octaves(random_warp(add2s(it.pos, 3.32849), 6 + 5*turbulence2, warp_scale), 7+p*0.2).y;
        w3 := 4*worley_octaves(random_warp(add2s(it.pos, 8.22643), 10 + 10*turbulence2, warp_scale), 10 + detail+p*0.2).y;
        w := w1*w1*w2*w3;
        *it.pixel = color_mul1(color, clamp_low(0.08, w*p));
    }

    // This is technically incorrect when rendered in blocks as the blur is incorrect
    // at block boundaries. But I can't notice it.
    blur_nebula := blur_to_copy(&nebula, 16);

    for (it := pixel_iter_begin(img, {}); pixel_iter_next(&it)) {
        d := tex_lookup(density, it.pos).r * 0.05;
        n := image_sample_nearest(&nebula, it.pos);
        nb := image_sample_nearest(&blur_nebula, it.pos);
        nnb := color_mul(n, nb);
        x := color_lerp(n, nnb, sparsity);
        y := color_add(n, x);
        z := color_pow(y, 2 + d * negative_space);
        z.a *= .333;

        *it.pixel = color_blend(*it.pixel, color_premultiply(z));
    }

    free_image(&nebula);
    free_image(&blur_nebula);
}

func draw_stars(dest: Image*, starfield: Starfield*) {
    for (i := 0; i < alen(starfield.stars); i++) {
        star := starfield.stars + i;
        draw_tex_multiply(dest, star.rect, &star.type.tex, star.color);
    }
}

func draw_starfield(dest: Image*, starfield: Starfield*) {
    draw_stars(dest, starfield);
    for (i := 0; i < starfield.nebula_properties.layer_count; i++) {
        draw_nebula(dest, &starfield.nebula_properties, starfield.nebula_properties.layers + i);
    }
}