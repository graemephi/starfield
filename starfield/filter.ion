func blur(img: Image*, radius: float) {
    blur_to(img, img, radius);
}

func blur_asym(img: Image*, radius: float2) {
    blur_to_asym(img, img, radius);
}

func blur_fetch(row: Color*, len: int, i: int): Color {
    if (i < 0 || i >= len) {
        return {};
    }

    return row[i];
}

func blur_row_slow(dest: Color*, src: Color*, len: int, radius: float) {
    #assert(radius > 0);
    r := clampi(0, len - 2, int(radius));
    a := radius - r;

    r_rcp :=  1. / (2. * radius + 1.);
    c_acc := color_mul1(blur_fetch(src, len, r + 1), a);

    for (i := 0; i <= r; i++) {
        c_acc = color_add(c_acc, blur_fetch(src, len, i));
    }

    for (i := 0; i < r + 1; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = color_sub(c_acc, color_lerp(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
    for (i := r + 1; i < len - r - 2; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(src[i+r+1], src[i+r+2], a));
        c_acc = color_sub(c_acc, color_lerp(src[i-r], src[i-r-1], a));
    }
    for (i := len - r - 2; i < len; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = color_sub(c_acc, color_lerp(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
}

func blur_row(dest: Color*, src: Color*, len: int, radius: float) {
    #assert(radius > 0);
    r := clampi(0, len - 2, int(radius));
    a := radius - r;

    r_rcp :=  1. / (2. * radius + 1.);
    c_acc := color_mul1(blur_fetch(src, len, r + 1), a);

    for (i := 0; i <= r; i++) {
        c_acc = color_add(c_acc, blur_fetch(src, len, i));
    }

    for (i := 0; i < r + 1; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = color_sub(c_acc, color_lerp(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
    for (i := r + 1; i < len - r - 2; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(src[i+r+1], src[i+r+2], a));
        c_acc = color_sub(c_acc, color_lerp(src[i-r], src[i-r-1], a));
    }
    for (i := len - r - 2; i < len; i++) {
        dest[i] = color_mul1(c_acc, r_rcp);
        c_acc = color_add(c_acc, color_lerp(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = color_sub(c_acc, color_lerp(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
}

func blur_transpose(dest: Color*, dest_width: int, src: Color*, src_width: int) {
    for (i := 0; i < src_width; i++) {
        *dest = *src;
        dest += dest_width;
        src++;
    }
}

func blur_horizontal(dest: Image*, src: Image*, radius: float) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    scratch: Color* = xcalloc(src.size.x, sizeof(Color));

    for (y := 0; y < src.size.y; y++) {
        row_src := src.pixels + y*src.size.x;
        row_dest := dest.pixels + y*dest.size.x;
        blur_row(row_dest, row_src, src.size.x, radius);
        blur_row(scratch, row_dest, src.size.x, radius);
        blur_row(row_dest, scratch, src.size.x, radius);
    }

    free(scratch);
}

func blur_vertical(dest: Image*, src: Image*, radius: float) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    scratch: Color* = xcalloc(src.size.y * 2, sizeof(Color));
    scratch_a := scratch;
    scratch_b := scratch + src.size.y;

    for (x := 0; x < src.size.x; x++) {
        for (i := 0; i < src.size.y; i++) {
            scratch_a[i] = src.pixels[x + i*src.size.x];
        }

        blur_row(scratch_b, scratch_a, src.size.y, radius);
        blur_row(scratch_a, scratch_b, src.size.y, radius);
        blur_row(scratch_b, scratch_a, src.size.y, radius);

        for (i := 0; i < dest.size.y; i++) {
            dest.pixels[x + i*dest.size.x] = scratch_b[i];
        }
    }

    free(scratch);
}

func blur_to(dest: Image*, src: Image*, radius: float) {
    #assert(dest.size.x == src.size.x);
    #assert(dest.size.y == src.size.y);

    temp := make_image({src.size.y, src.size.x});
    scratch: Color* = xcalloc(maxi(src.size.x, src.size.y), sizeof(Color));

    for (y := 0; y < src.size.y; y++) {
        row_src := src.pixels + y*src.size.x;
        row_dest := dest.pixels + y*dest.size.x;
        blur_row(scratch, row_src, src.size.x, radius);
        blur_row(row_dest, scratch, src.size.x, radius);
        blur_row(scratch, row_dest, src.size.x, radius);
        blur_transpose(temp.pixels + y, temp.size.x, scratch, src.size.x);
    }

    for (y := 0; y < temp.size.y; y++) {
        row := temp.pixels + y*temp.size.x;
        blur_row(scratch, row, temp.size.x, radius);
        blur_row(row, scratch, temp.size.x, radius);
        blur_row(scratch, row, temp.size.x, radius);
        blur_transpose(dest.pixels + y, dest.size.x, scratch, temp.size.x);
    }


    free_image(&temp);
    free(scratch);
}

func blur_to_asym(dest: Image*, src: Image*, radius: float2) {
    #assert(dest.size.x == src.size.x);
    #assert(dest.size.y == src.size.y);

    temp := make_image({src.size.y, src.size.x});
    scratch: Color* = xcalloc(maxi(src.size.x, src.size.y), sizeof(Color));

    for (i := 0; i < 3; i++) {
        for (y := 0; y < src.size.y; y++) {
            row_src := src.pixels + y*src.size.x;
            row_dest := dest.pixels + y*dest.size.x;
            blur_row(scratch, row_src, src.size.x, radius.x);
            blur_transpose(temp.pixels + y, temp.size.x, scratch, src.size.x);
        }

        for (y := 0; y < temp.size.y; y++) {
            row := temp.pixels + y*temp.size.x;
            blur_row(scratch, row, temp.size.x, radius.y);
            blur_transpose(dest.pixels + y, dest.size.x, scratch, temp.size.x);
        }
    }

    free_image(&temp);
    free(scratch);
}

func diffract_fetch(row: float*, len: int, i: int): float {
    if (i < 0 || i >= len) {
        return {};
    }

    return row[i];
}

func diffract_row(dest: float*, src: float*, len: int, inner_radius: float, outer_radius: float) {
    #assert(inner_radius > 0);
    #assert(outer_radius > inner_radius);

    r := clampi(0, len - 2, int(inner_radius));
    r2 := clampi(0, len - 3, int(outer_radius));
    a := inner_radius - r;
    a2 := outer_radius - r2;

    r_rcp :=  1. / (2 * (outer_radius - inner_radius));

    c_sub := diffract_fetch(src, len, r + 1) * a;
    c_acc := diffract_fetch(src, len, r2 + 1) * a2;

    for (i := 0; i <= r2; i++) {
        if (i <= r) {
            c_sub += diffract_fetch(src, len, i);
        }
        c_acc += diffract_fetch(src, len, i);
    }

    for (i := 0; i < r2 + 1; i++) {
        dest[i] = (c_acc - c_sub) * r_rcp;
        c_acc += lerp(diffract_fetch(src, len, i+r2+1), diffract_fetch(src, len, i+r2+2), a2);
        c_acc -= lerp(diffract_fetch(src, len, i-r2), diffract_fetch(src, len, i-r2-1), a2);
        c_sub += lerp(diffract_fetch(src, len, i+r+1), diffract_fetch(src, len, i+r+2), a);
        c_sub -= lerp(diffract_fetch(src, len, i-r), diffract_fetch(src, len, i-r-1), a);
    }
    for (i := r2 + 1; i < len - r2 - 2; i++) {
        dest[i] = (c_acc - c_sub) * r_rcp;
        c_acc += lerp(src[i+r2+1], src[i+r2+2], a2);
        c_acc -= lerp(src[i-r2], src[i-r2-1], a2);
        c_sub += lerp(src[i+r+1], src[i+r+2], a);
        c_sub -= lerp(src[i-r], src[i-r-1], a);
    }
    for (i := len - r2 - 2; i < len; i++) {
        dest[i] = (c_acc - c_sub) * r_rcp;
        c_acc += lerp(diffract_fetch(src, len, i+r2+1), diffract_fetch(src, len, i+r2+2), a2);
        c_acc -= lerp(diffract_fetch(src, len, i-r2), diffract_fetch(src, len, i-r2-1), a2);
        c_sub += lerp(diffract_fetch(src, len, i+r+1), diffract_fetch(src, len, i+r+2), a);
        c_sub -= lerp(diffract_fetch(src, len, i-r), diffract_fetch(src, len, i-r-1), a);
    }
}


const diffraction_iters = 4;
func diffract_plane(plane: float*, scratch: float*, transpose_scratch: float*, size: int2, inner_radius: float, outer_radius: float) {
    for (y := 0; y < size.y; y++) {
        plane_row := plane + y*size.x;

        if (transpose_scratch) {
            for (i := 0; i < size.x; i++) {
                transpose_scratch[y + i*size.y] = plane_row[i];
            }
        }

        for (i := 0; i < diffraction_iters; i++) {
            diffract_row(scratch, plane_row, size.x, inner_radius, outer_radius);
            diffract_row(plane_row, scratch, size.x, inner_radius, outer_radius);
        }
    }

    if (transpose_scratch) {
        for (x := 0; x < size.x; x++) {
            transpose_row := transpose_scratch + x*size.y;

            for (i := 0; i < diffraction_iters; i++) {
                diffract_row(scratch, transpose_row, size.y, inner_radius, outer_radius);
                diffract_row(transpose_row, scratch, size.y, inner_radius, outer_radius);
            }

            for (i := 0; i < size.y; i++) {
                plane[x + i*size.x] += transpose_row[i];
            }
        }
    }
}

func planarise(img: Image*): float* {
    pixel_count := img.size.x*img.size.y;
    #assert(pixel_count % 4 == 0);
    pixels: float* = xcalloc(pixel_count, sizeof(float)*3);

    for (i := 0; i < pixel_count; i++) {
        pixels[i] = img.pixels[i].r;
        pixels[i + pixel_count] = img.pixels[i].g;
        pixels[i + 2*pixel_count] = img.pixels[i].b;
    }

    return pixels;
}

func is_identity_transform(transform: float2): bool {
    return (transform.x == 0 || transform.x == 1) && (transform.y == 0);
}

func transform_image(src: Image*, rotate: float2, scale: float2): Image {
    size := int2 { int(scale.x * src.size.x), int(scale.y * src.size.y) };
    result := make_image(size);

    inverse_rect := all_rect();
    inverse_rect.size = { 1. / scale.x, 1. / scale.y };
    inverse_rect.size.x /= (float(src.size.x) / src.size.y);
    inverse_rect.rot = { rotate.x, -rotate.y };

    for (it := pixel_iter_begin(&result, inverse_rect); pixel_iter_next(&it)) {
        *it.pixel = image_sample_linear(src, it.pos);
    }

    return result;
}

func bounds_after_transform(transform: float2, aspect_ratio: float): float2 {
    r := all_rect();
    r.rot = transform;
    a := rect_absolute(r, aspect_ratio, {0,0});
    b := rect_absolute(r, aspect_ratio, {1,0});
    c := rect_absolute(r, aspect_ratio, {0,1});
    d := rect_absolute(r, aspect_ratio, {1,1});

    x_min := min4(a.x, b.x, c.x, d.x);
    x_max := max4(a.x, b.x, c.x, d.x);
    y_min := min4(a.y, b.y, c.y, d.y);
    y_max := max4(a.y, b.y, c.y, d.y);

    x := x_max - x_min;
    y := y_max - y_min;

    return { x, y };
}

enum DiffractionType {
    Diffraction_None,
    Diffraction_Cross,
    Diffraction_CrossOrthoRed,
    Diffraction_Single,

    DiffractionTypeCount
}

struct DiffractionArguments {
    alpha: float;
    radius: float;
    transform: float2;
    type: DiffractionType;
}

func apply_diffraction(dest: Image*, alpha: Color, radius: float, transform: float2, transformed_bounds: float2, scratch: float*, transpose_scratch: float* /* nullable */) {
    rotation := float2 { 1, 0 };

    img := dest;
    if (is_identity_transform(transform) == false) {
        m := magnitude2(transform);
        rotation = float2 { transform.x / m,  transform.y / m };
        transformed_img := transform_image(dest, rotation, transformed_bounds);
        img = &transformed_img;
    }

    inner_radius := radius * 0.25;
    outer_radius := radius / 1.4;
    inner_radius_transpose := inner_radius * (float(img.size.y) / img.size.x);
    outer_radius_transpose := outer_radius * (float(img.size.y) / img.size.x);

    pixel_count := img.size.x*img.size.y;
    planes := planarise(img);

    red := planes;
    green := planes + pixel_count;
    blue := planes + 2*pixel_count;
    diffract_plane(red, scratch, transpose_scratch, img.size, inner_radius, outer_radius);
    diffract_plane(green, scratch, transpose_scratch, img.size, inner_radius * 1.1, outer_radius * 1.2);
    diffract_plane(blue, scratch, transpose_scratch, img.size, inner_radius * 1.2, outer_radius * 1.4);

    if (img.pixels == dest.pixels) {
        for (i := 0; i < pixel_count; i++) {
            dest.pixels[i].r += alpha.r*red[i];
            dest.pixels[i].g += alpha.g*green[i];
            dest.pixels[i].b += alpha.b*blue[i];
        }
    } else {
        scale := float2 { 1. / transformed_bounds.x, 1. / transformed_bounds.y };
        scale.x /= (float(dest.size.x) / dest.size.y);
        offset := float2 { 0.5, 0.5 };
        for (it := pixel_iter_begin(dest, {}); pixel_iter_next(&it)) {
            pos := add2(mul2(rotate(sub2(it.pos, offset), rotation), scale), { 0.5, 0.5 });

            if (inside_normal_rect(pos)) {
                it.pixel.r += alpha.r*sample_linear(red, img.size, pos, Edge_Wrap);
                it.pixel.g += alpha.g*sample_linear(green, img.size, pos, Edge_Wrap);
                it.pixel.b += alpha.b*sample_linear(blue, img.size, pos, Edge_Wrap);
            }
        }
        free_image(img);
    }

    free(planes);
}

func diffract(img: Image*, args: DiffractionArguments) {
    if (args.type == Diffraction_None) {
        return;
    }

    alpha := args.alpha == 0 ? 1 : args.alpha;
    radius := args.radius == 0 ? 1 : args.radius;
    transform := is_identity_transform(args.transform) ? float2 { 1, 0 } : args.transform;
    aspect_ratio := float(img.size.x) / float(img.size.y);

    bounds := bounds_after_transform(transform, aspect_ratio);
    m := magnitude2(transform);
    working_size := int2 { int(img.size.x * m * 3 / 2), int(img.size.y * m * 3 / 2) };

    scratch_buf_size := maxi(working_size.x, working_size.y);
    transpose_scratch_size := 0;

    if (args.type != Diffraction_Single) {
        transpose_scratch_size = working_size.x*working_size.y;
    }

    scratch_buf: float* = xcalloc(scratch_buf_size + transpose_scratch_size, sizeof(float));
    tranpose_scratch := transpose_scratch_size ? scratch_buf + scratch_buf_size : 0;

    apply_diffraction(img, { alpha, alpha, alpha }, radius, transform, bounds, scratch_buf, tranpose_scratch);

    if (args.type == Diffraction_CrossOrthoRed) {
        ortho := rotate(args.transform, mul2s({ InvSqrt2, InvSqrt2 }, 0.7));
        ortho_bounds := bounds_after_transform(ortho, aspect_ratio);
        ortho_working_size := int2 { int(img.size.x * ortho_bounds.x), int(img.size.y * ortho_bounds.y) };
        #assert(maxi(ortho_working_size.x, ortho_working_size.y) < scratch_buf_size);
        #assert((ortho_working_size.x * ortho_working_size.y) < transpose_scratch_size);
        apply_diffraction(img, { alpha, alpha*.6, alpha*.2 }, radius, ortho, ortho_bounds, scratch_buf, tranpose_scratch);
    }

    free(scratch_buf);
}