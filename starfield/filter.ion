func blur(img: Image*, radius: float) {
    blur_to(img, img, radius);
}

func blur_asym(img: Image*, radius: float2) {
    blur_to_asym(img, img, radius);
}

// Nothing else in this file knows about writable regions
func blur_region(img: Image*, radius: float) {
    wr := explicit_writable_region(img);

    // Contiguous bytes.
    #assert(wr.x0 == 0 && wr.x1 == img.size.x);

    region := *img;
    region.pixels = img.pixels + (wr.x0 + wr.y0*img.size.x);
    region.size = { wr.x1 - wr.x0, wr.y1 - wr.y0 };
    blur(&region, radius);
}

func blur_fetch(row: Color*, len: int, i: int): float4 {
    if (i < 0 || i >= len) {
        return zero4();
    }

    return color_load(row + i);
}

func blur_row(dest: Color*, src: Color*, len: int, radius: float) {
    #assert(radius > 0);
    r := clampi(0, len - 2, int(radius));
    a := radius - r;

    r_rcp :=  1. / (2. * radius + 1.);
    c_acc := mul4s(blur_fetch(src, len, r + 1), a);

    for (i := 0; i <= r; i++) {
        c_acc = add4(c_acc, blur_fetch(src, len, i));
    }

    for (i := 0; i < r + 1; i++) {
        store4((:float*)(dest + i), mul4s(c_acc, r_rcp));
        c_acc = add4(c_acc, lerp4s(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = sub4(c_acc, lerp4s(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
    for (i := r + 1; i < len - r - 2; i++) {
        store4((:float*)(dest + i), mul4s(c_acc, r_rcp));
        c_acc = add4(c_acc, lerp4s(color_load(src + i+r+1), color_load(src + i+r+2), a));
        c_acc = sub4(c_acc, lerp4s(color_load(src + i-r), color_load(src + i-r-1), a));
    }
    for (i := len - r - 2; i < len; i++) {
        store4((:float*)(dest + i), mul4s(c_acc, r_rcp));
        c_acc = add4(c_acc, lerp4s(blur_fetch(src, len, i+r+1), blur_fetch(src, len, i+r+2), a));
        c_acc = sub4(c_acc, lerp4s(blur_fetch(src, len, i-r), blur_fetch(src, len, i-r-1), a));
    }
}

func blur_transpose(dest: Color*, dest_width: int, src: Color*, src_width: int) {
    for (i := 0; i < src_width; i++) {
        *dest = *src;
        dest += dest_width;
        src++;
    }
}

func blur_horizontal(dest: Image*, src: Image*, radius: float) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    scratch: Color* = xcalloc(src.size.x, sizeof(Color));

    for (y := 0; y < src.size.y; y++) {
        row_src := src.pixels + y*src.size.x;
        row_dest := dest.pixels + y*dest.size.x;
        blur_row(row_dest, row_src, src.size.x, radius);
        blur_row(scratch, row_dest, src.size.x, radius);
        blur_row(row_dest, scratch, src.size.x, radius);
    }

    xfree(scratch);
}

func blur_vertical(dest: Image*, src: Image*, radius: float) {
    #assert(src.size.x == dest.size.x);
    #assert(src.size.y == dest.size.y);
    scratch: Color* = xcalloc(src.size.y * 2, sizeof(Color));
    scratch_a := scratch;
    scratch_b := scratch + src.size.y;

    for (x := 0; x < src.size.x; x++) {
        for (i := 0; i < src.size.y; i++) {
            scratch_a[i] = src.pixels[x + i*src.size.x];
        }

        blur_row(scratch_b, scratch_a, src.size.y, radius);
        blur_row(scratch_a, scratch_b, src.size.y, radius);
        blur_row(scratch_b, scratch_a, src.size.y, radius);

        for (i := 0; i < dest.size.y; i++) {
            dest.pixels[x + i*dest.size.x] = scratch_b[i];
        }
    }

    xfree(scratch);
}

func blur_to(dest: Image*, src: Image*, radius: float) {
    #assert(dest.size.x == src.size.x);
    #assert(dest.size.y == src.size.y);

    temp := make_image({src.size.y, src.size.x});
    scratch: Color* = xcalloc(maxi(src.size.x, src.size.y), sizeof(Color));

    for (y := 0; y < src.size.y; y++) {
        row_src := src.pixels + y*src.size.x;
        row_dest := dest.pixels + y*dest.size.x;
        blur_row(scratch, row_src, src.size.x, radius);
        blur_row(row_dest, scratch, src.size.x, radius);
        blur_row(scratch, row_dest, src.size.x, radius);
        blur_transpose(temp.pixels + y, temp.size.x, scratch, src.size.x);
    }

    for (y := 0; y < temp.size.y; y++) {
        row := temp.pixels + y*temp.size.x;
        blur_row(scratch, row, temp.size.x, radius);
        blur_row(row, scratch, temp.size.x, radius);
        blur_row(scratch, row, temp.size.x, radius);
        blur_transpose(dest.pixels + y, dest.size.x, scratch, temp.size.x);
    }


    free_image(&temp);
    xfree(scratch);
}

func blur_to_asym(dest: Image*, src: Image*, radius: float2) {
    #assert(dest.size.x == src.size.x);
    #assert(dest.size.y == src.size.y);

    temp := make_image({src.size.y, src.size.x});
    scratch: Color* = xcalloc(maxi(src.size.x, src.size.y), sizeof(Color));

    for (i := 0; i < 3; i++) {
        for (y := 0; y < src.size.y; y++) {
            row_src := src.pixels + y*src.size.x;
            blur_row(scratch, row_src, src.size.x, radius.x);
            blur_transpose(temp.pixels + y, temp.size.x, scratch, src.size.x);
        }

        for (y := 0; y < temp.size.y; y++) {
            row := temp.pixels + y*temp.size.x;
            blur_row(scratch, row, temp.size.x, radius.y);
            blur_transpose(dest.pixels + y, dest.size.x, scratch, temp.size.x);
        }
    }

    free_image(&temp);
    xfree(scratch);
}

func diffract_fetch(row: float*, len: int, i: int): float {
    if (i < 0 || i >= len) {
        return {};
    }

    return row[i << 2];
}

func diffract_row(dest: Color*, src: Color*, len: int, inner_radius: float[4], outer_radius: float[4]) {
    for (k := 0; k < 4; k++) {
        #assert(inner_radius[k] > 0);
        #assert(outer_radius[k] > inner_radius[k]);

        src_f32 := ((:float*)src) + k;

        ir := clamp(0, len - 2., inner_radius[k]);
        or := clamp(0, len - 3., outer_radius[k]);

        r := int(ir);
        r2 := int(or);

        a := ir - r;
        a2 := or - r2;

        r_rcp :=  1. / (2 * (or - ir));

        c_sub := diffract_fetch(src_f32, len, r + 1) * a;
        c_acc := diffract_fetch(src_f32, len, r2 + 1) * a2;

        for (i := k; i <= r2; i++) {
            if (i <= r) {
                c_sub += diffract_fetch(src_f32, len, i);
            }
            c_acc += diffract_fetch(src_f32, len, i);
        }

        dest_cursor_a := ((:float*)dest) + k;
        for (i := 0; i < r2 + 1; i++) {
            *dest_cursor_a = (c_acc - c_sub) * r_rcp;
            dest_cursor_a += 4;
            c_acc += lerp(diffract_fetch(src_f32, len, i+r2+1), diffract_fetch(src_f32, len, i+r2+2), a2);
            c_acc -= lerp(diffract_fetch(src_f32, len, i-r2), diffract_fetch(src_f32, len, i-r2-1), a2);
            c_sub += lerp(diffract_fetch(src_f32, len, i+r+1), diffract_fetch(src_f32, len, i+r+2), a);
            c_sub -= lerp(diffract_fetch(src_f32, len, i-r), diffract_fetch(src_f32, len, i-r-1), a);
        }

        dest_cursor_b := ((:float*)(dest + r2 + 1)) + k;
        for (i := r2 + 1; i < len - r2 - 2; i++) {
            *dest_cursor_b = (c_acc - c_sub) * r_rcp;
            dest_cursor_b += 4;
            c_acc += lerp(src_f32[(i+r2+1) * 4], src_f32[(i+r2+2) * 4], a2);
            c_acc -= lerp(src_f32[(i-r2) * 4], src_f32[(i-r2-1) * 4], a2);
            c_sub += lerp(src_f32[(i+r+1) * 4], src_f32[(i+r+2) * 4], a);
            c_sub -= lerp(src_f32[(i-r) * 4], src_f32[(i-r-1) * 4], a);
        }

        dest_cursor_c := ((:float*)(dest + len - r2 - 2)) + k;
        for (i := len - r2 - 2; i < len; i++) {
            *dest_cursor_c = (c_acc - c_sub) * r_rcp;
            dest_cursor_c += 4;
            c_acc += lerp(diffract_fetch(src_f32, len, i+r2+1), diffract_fetch(src_f32, len, i+r2+2), a2);
            c_acc -= lerp(diffract_fetch(src_f32, len, i-r2), diffract_fetch(src_f32, len, i-r2-1), a2);
            c_sub += lerp(diffract_fetch(src_f32, len, i+r+1), diffract_fetch(src_f32, len, i+r+2), a);
            c_sub -= lerp(diffract_fetch(src_f32, len, i-r), diffract_fetch(src_f32, len, i-r-1), a);
        }
        #assert((:Color*)dest_cursor_c - dest == len);
    }
}

const diffraction_iters = 4;
func diffract_blur(img: Image*, scratch: Color*, transpose_scratch: Color*, size: int2, inner_radius: float[4], outer_radius: float[4]) {
    for (y := 0; y < size.y; y++) {
        row := img.pixels + y*size.x;

        if (transpose_scratch) {
            for (i := 0; i < size.x; i++) {
                transpose_scratch[y + i*size.y] = row[i];
            }
        }

        for (i := 0; i < diffraction_iters; i++) {
            diffract_row(scratch, row, size.x, inner_radius, outer_radius);
            diffract_row(row, scratch, size.x, inner_radius, outer_radius);
        }
    }

    if (transpose_scratch) {
        for (x := 0; x < size.x; x++) {
            transpose_row := transpose_scratch + x*size.y;

            for (i := 0; i < diffraction_iters; i++) {
                diffract_row(scratch, transpose_row, size.y, inner_radius, outer_radius);
                diffract_row(transpose_row, scratch, size.y, inner_radius, outer_radius);
            }

            for (i := 0; i < size.y; i++) {
                img.pixels[x + i*size.x] = color_add(img.pixels[x + i*size.x], transpose_row[i]);
            }
        }
    }
}

func is_identity_transform(transform: float2): bool {
    return (transform.x == 0 || transform.x == 1) && (transform.y == 0);
}

func transform_image(src: Image*, rotate: float2, scale: float2): Image {
    size := int2 { int(scale.x * src.size.x), int(scale.y * src.size.y) };
    result := make_image(size);

    inverse_rect := all_rect(src);
    inverse_rect.size = { 1. / scale.y, 1. / scale.y };
    inverse_rect.rot = { rotate.x, -rotate.y };

    for (it := pixel_iter_begin(&result, inverse_rect); pixel_iter_next(&it)) {
        *it.pixel = image_sample_linear(src, it.pos);
    }

    return result;
}

func bounds_after_transform(img: Image*, transform: float2): float2 {
    r := all_rect(img);
    r.rot = transform;
    a := rect_to_image(img, r, {0,0});
    b := rect_to_image(img, r, {1,0});
    c := rect_to_image(img, r, {0,1});
    d := rect_to_image(img, r, {1,1});

    x_min := smin4(a.x, b.x, c.x, d.x);
    x_max := smax4(a.x, b.x, c.x, d.x);
    y_min := smin4(a.y, b.y, c.y, d.y);
    y_max := smax4(a.y, b.y, c.y, d.y);

    x := x_max - x_min;
    y := y_max - y_min;

    return { x, y };
}

func apply_diffraction(dest: Image*, alpha: Color, radius: float, transform: float2, transformed_bounds: float2, scratch: Color*, transpose_scratch: Color* /* nullable */) {
    rotation := float2 { 1, 0 };

    img := dest;
    transformed: Image;
    if (is_identity_transform(transform) == false) {
        m := magnitude2(transform);
        rotation = float2 { transform.x / m,  transform.y / m };
        transformed = transform_image(dest, rotation, transformed_bounds);
        img = &transformed;
    }

    inner_radius: float[4] = { radius * .25, radius * .25 * 1.1, radius * .25 * 1.2, radius * .25 * 1.2 };
    outer_radius: float[4] = { radius * .70, radius * .70 * 1.2, radius * .70 * 1.4, radius * .70 * 1.4 };

    pixel_count := img.size.x*img.size.y;
    diffract_blur(img, scratch, transpose_scratch, img.size, inner_radius, outer_radius);

    if (img.pixels == dest.pixels) {
        for (i := 0; i < pixel_count; i++) {
            dest.pixels[i] = color_add(dest.pixels[i], color_mul(img.pixels[i], alpha));
        }
    } else {
        scale := float2 { 1. / transformed_bounds.y, 1. / transformed_bounds.y };
        offset := float2 { 0.5, 0.5 };
        for (it := pixel_iter_begin(dest, {}); pixel_iter_next(&it)) {
            pos := add2(mul2(rotate(sub2(it.pos, offset), rotation), scale), { 0.5 * it.aspect_ratio, 0.5 });

            if (inside_normal_rect(pos, it.aspect_ratio)) {
                *it.pixel = color_add(*it.pixel, color_mul(image_sample_linear(img, pos), alpha));
            }
        }
        free_image(img);
    }
}

enum DiffractionType {
    Diffraction_None,
    Diffraction_Cross,
    Diffraction_CrossOrthoRed,
    Diffraction_Single,

    DiffractionTypeCount
}

struct DiffractionArguments {
    alpha: float;
    radius: float;
    transform: float2;
    type: DiffractionType;
}

func diffract(img: Image*, args: DiffractionArguments) {
    if (args.type == Diffraction_None) {
        return;
    }

    alpha := args.alpha == 0 ? 1 : args.alpha;
    radius := args.radius == 0 ? 1 : args.radius;
    transform := is_identity_transform(args.transform) ? float2 { 1, 0 } : args.transform;

    bounds := bounds_after_transform(img, transform);
    m := magnitude2(transform);
    working_size := int2 { int(img.size.x * m * 3 / 2), int(img.size.y * m * 3 / 2) };

    scratch_buf_size := maxi(working_size.x, working_size.y);

    if (scratch_buf_size & 15) {
        scratch_buf_size += 16 - (scratch_buf_size & 15);
    }

    transpose_scratch_size := 0;

    if (args.type != Diffraction_Single) {
        transpose_scratch_size = working_size.x * working_size.y;
    }

    scratch_buf: Color* = xcalloc(scratch_buf_size + transpose_scratch_size, sizeof(Color));
    tranpose_scratch := transpose_scratch_size ? (scratch_buf + scratch_buf_size) : 0;

    apply_diffraction(img, { alpha, alpha, alpha, 1 }, radius, transform, bounds, scratch_buf, tranpose_scratch);

    if (args.type == Diffraction_CrossOrthoRed) {
        ortho := rotate(args.transform, mul2s({ InvSqrt2, InvSqrt2 }, 0.7));
        ortho_bounds := bounds_after_transform(img, ortho);
        ortho_working_size := int2 { int(img.size.x * ortho_bounds.x), int(img.size.y * ortho_bounds.y) };
        #assert(maxi(ortho_working_size.x, ortho_working_size.y) < scratch_buf_size);
        #assert((ortho_working_size.x * ortho_working_size.y) < transpose_scratch_size);
        apply_diffraction(img, { alpha, alpha*.6, alpha*.2, 1 }, radius, ortho, ortho_bounds, scratch_buf, tranpose_scratch);
    }

    xfree(scratch_buf);
}